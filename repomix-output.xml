This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shared/
  schemas.ts
src/
  components/
    MdxRenderer.tsx
    Pane.tsx
  fixtures/
    dialogue.json
  replay/
    bus.ts
    controller.ts
  App.tsx
  main.tsx
.gitignore
flake.lock
flake.nix
index.html
index.ts
package.json
server.ts
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import { ChakraProvider, defaultSystem } from "@chakra-ui/react";
import { App } from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ChakraProvider value={defaultSystem}>
      <App />
    </ChakraProvider>
  </React.StrictMode>,
);
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1767039857,
        "narHash": "sha256-vNpUSpF5Nuw8xvDLj2KCwwksIbjua2LZCqhV1LNRDns=",
        "owner": "NixOS",
        "repo": "flake-compat",
        "rev": "5edf11c44bc78a0d334f6334cdaf7d60d732daab",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "git-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1771858127,
        "narHash": "sha256-Gtre9YoYl3n25tJH2AoSdjuwcqij5CPxL3U3xysYD08=",
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "49bbbfc218bf3856dfa631cead3b052d78248b83",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "git-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1770073757,
        "narHash": "sha256-Vy+G+F+3E/Tl+GMNgiHl9Pah2DgShmIUBJXmbiQPHbI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "47472570b1e607482890801aeaf29bfb749884f6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1771848320,
        "narHash": "sha256-0MAd+0mun3K/Ns8JATeHT1sX28faLII5hVLq0L3BdZU=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2fc6539b481e1d2569f25f8799236694180c0993",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "git-hooks": "git-hooks",
        "nixpkgs": "nixpkgs_2"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="index.html">
<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Minimal Bun + React</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
</file>

<file path="index.ts">
console.log("Hello via Bun!");
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "moduleDetection": "force",
    "verbatimModuleSyntax": true,
    "allowImportingTsExtensions": true,

    "noEmit": true,

    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  },
  "include": ["src", "shared", "server.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001",
    },
  },
});
</file>

<file path="src/components/MdxRenderer.tsx">
import React from "react";
import { Box } from "@chakra-ui/react";
import { MarkdownHooks } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeMermaid from "rehype-mermaid";

export function MdxRenderer({ content }: { content: string }) {
  return (
    <Box
      css={{
        "& p": { mb: 3, lineHeight: 1.7 },
        "& ul": { pl: 6, mb: 3 },
        "& li": { mb: 1.5 },
        "& pre": {
          bg: "surface",
          p: 4,
          borderRadius: "lg",
          borderWidth: "1px",
          overflowX: "auto",
        },
        "& code": {
          bg: "subtle",
          px: 2,
          py: 1,
          borderRadius: "md",
        },
        "& svg": {
          bg: "surface",
          borderRadius: "lg",
          p: 2,
        },
      }}
    >
      <MarkdownHooks
        key={content}
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[[rehypeMermaid, { strategy: "inline-svg" }]]}
      >
        {content}
      </MarkdownHooks>
    </Box>
  );
}
</file>

<file path="src/fixtures/dialogue.json">
{
  "topic": "Zero trust in microservices",
  "turns": [
    {
      "speaker": "security_engineer",
      "mdx": "We should adopt a strict zero-trust posture for east‑west traffic using workload identities (SPIFFE), mTLS between sidecars, and OPA for fine‑grained policy enforcement.\n\nKey points:\n\n- Authenticate by identity, not network: SPIFFE SVIDs issued by SPIRE; short‑lived X.509 (or JWT‑SVID) for revocation-free rotation.\n- Encrypt and authorize at the edge of the workload: Envoy/sidecar mTLS, Envoy RBAC + OPA as an external authorizer.\n- Deny‑by‑default RBAC and attribute‑based policies (OPA/Rego) for sensitive calls (database, secrets manager).\n- Rollout strategy: permissive mTLS -> canary (5–25%) -> all, and use chaos engineering to verify cert expiry recovery paths.\n\nConcrete failure cases to prepare for:\n\n- SPIRE control plane compromise: have offline root CA and automated rotation playbooks.\n- Certificate expiry or network partition: use permissive mode with strict audit for short windows and automatic restart/renewal agents.\n\nI expect pushback on complexity and latency; I’ll address trade‑offs if you outline those concerns."
    },
    {
      "speaker": "application_engineer",
      "mdx": "I agree with identity‑first goals, but I push back on mandatory sidecars + Envoy for every service because of operational and performance costs.\n\nProblems I see:\n\n- CPU and latency: Envoy sidecars add p99 tail latency and ~5–15% CPU overhead in polyglot fleets.\n- Integration friction: not every runtime team can embed SPIFFE SDKs; sidecars can be heavy for small services (FaaS/edge devices).\n- Centralized OPA policies become deployment coupling: a policy change can break many services and slow down releases.\n\nA pragmatic alternative I propose:\n\n- North‑south: API gateway enforces strong auth (JWT introspection, rate limiting, WAF). Use token caches and introspection caching.\n- East‑west hybrid: critical services use SPIFFE mTLS; noncritical internal calls use signed JWTs with short TTL + local verification.\n- Gradual rollout: start gateway + JWTs, then progressively onboard service mesh for high‑risk paths.\n\nI want to see concrete latency measurements and rollout knobs before committing cluster‑wide sidecars."
    },
    {
      "speaker": "security_engineer",
      "mdx": "Good points — latency and operational burden are real. Still, JWTs and gateway‑only enforcement have concrete attack windows:\n\n- Replay and revocation: long‑lived JWTs are hard to revoke; token introspection adds central dependency and latency spikes.\n- Gateway compromise: a single compromised ingress gateway could mint or forward tokens to east‑west paths if we rely on gateway trust alone.\n\nHow we mitigate while addressing your concerns:\n\n- Use SPIFFE short‑lived SVIDs (X.509 or JWT‑SVID). TTLs of 10–30 minutes eliminate long revocation windows and avoid introspection for every call.\n- Reduce sidecar overhead: leverage eBPF or kernel bypass (Envoy’s XDP/AF_XDP or gVisor bypass patterns) for hot paths; restrict full proxy to critical services.\n- Rollout concretely:\n  - Phase 1: deploy SPIRE server + agents on control plane nodes; run Envoy in permissive mode (mTLS verified but not required) for 2 weeks.\n  - Phase 2: canary 5% of services with enforced mTLS and OPA policies; monitor p99 auth latency, CPU delta, and error rate.\n  - Phase 3: expand by risk category.\n\nFailure/callback plan:\n\n- If SPIRE unavailable, agents continue serving cached SVIDs until expiry; set TTLs short but long enough to survive brief outages (e.g., 15m).\n- For wider outages, auto‑rollback to permissive with strict logging and alerts, not fail‑open permanently."
    },
    {
      "speaker": "application_engineer",
      "mdx": "Accepting JWT replay concerns and the SPIFFE short‑lived solution helps. Still, the devil is in operational details and developer velocity.\n\nOperational trade‑offs I want addressed before full adoption:\n\n- SDK vs sidecar: SDKs avoid heavy sidecars but create language‑specific maintenance across many teams. Sidecars centralize complexity but hurt resource budgets.\n- Observability/perf KPIs: we need concrete thresholds before canary expansion (acceptable p99 increase, CPU budget per pod, memory).\n- Policy ownership: OPA as a centralized policy store needs guardrails (policy review workflow, testing harnesses).\n\nProposed hybrid implementation to compromise:\n\n- Use SPIRE agents + sidecars for critical, high‑risk services (payments, auth, db proxies).\n- Use JWT‑SVID (SPIFFE supports JWT‑SVID) for lightweight validation in low‑risk services — apps validate locally with a stable public key bundle.\n- Deploy OPA as a local sidecar for low latency but keep a central OPA server for policy authorship and CI testing; use policy signing and automated promotion.\n\nAlso, we should create canary KPIs: start at 5% traffic, expand if p99 auth latency delta <2ms and CPU overhead <5%."
    },
    {
      "speaker": "security_engineer",
      "mdx": "I like the hybrid shape and it's consistent with SPIFFE capabilities. A few concrete mechanisms and operational controls I insist on:\n\n- Use JWT‑SVIDs where appropriate: SPIRE issues JWT‑SVIDs so apps can validate tokens offline using the trust bundle (no introspection). This addresses your SDK concern without sacrificing short TTLs.\n- Policy enforcement: use Envoy RBAC + OPA plugin for complex attribute logic; OPA Gatekeeper for K8s admission controls to stop misconfigurations.\n- Failover and TTL specifics:\n  - Certificate/SVID TTL: 10–30 minutes (trade‑off: shorter TTL reduces compromise window but increases issuance load).\n  - SPIRE HA: run SPIRE server as an HA set; monitor issuance latency and queue length; alert at issuance latency >500ms or queue >1000.\n- Rollback strategy: permissive mode with strict audit for a maximum window (e.g., 4 hours) and automated rollback if:\n  - p99 auth latency increases >2ms above baseline, or\n  - request error rate increases by >1% absolute, or\n  - CPU overhead >7% on canary pods.\n\nMinimal diagram of the flow:\n\n```mermaid\nflowchart LR\n  A[workload] -->|fetch SVID| B[SPIRE agent]\n  A -->|mTLS| C[sidecar Envoy]\n  C -->|policy check| D[OPA sidecar]\n  D --> E[target service]\n```\n\nI’ll own SPIRE outage playbooks and automated alerts if we agree on the KPI thresholds above."
    },
    {
      "speaker": "application_engineer",
      "mdx": "That diagram and the concrete thresholds make the plan actionable. I accept the hybrid architecture provided we lock down these operational SLAs and automation steps:\n\n- KPIs and rollout gates:\n  - Canary progression: 5% -> 25% -> 100% when p99 auth latency delta <= 2ms and CPU overhead <= 5%.\n  - If error rate increases >1% or auth failures >0.1% for 10 minutes, auto‑rollback to permissive for affected canaries.\n- Performance mitigations:\n  - Use eBPF for in‑kernel fast path where possible and an Envoy wasm filter for lightweight policy checks.\n  - Cache public bundles for JWT‑SVID validation, refresh off‑peak.\n- Responsibilities:\n  - Security owns SPIRE HA, TTL tuning, and automated rollback playbooks.\n  - Platform owns sidecar deployment patterns, eBPF integration, and a policy CI that validates Rego on test traffic.\n\nIf you commit to those duties and the canary gates, I’ll start a pilot with three critical services and measure metrics for two weeks before broader rollout."
    }
  ]
}
</file>

<file path="src/replay/bus.ts">
import mitt from "mitt";
import type { Turn } from "../../shared/schemas";

export type Pane = "security" | "application";

export type Events = {
  REPLAY_START: void;
  APPEND_TURN: Turn;
  REPLAY_COMPLETE: void;

  // NEW
  TURN_RENDERED: {
    id: string;
    height: number;
  };
};

export const bus = mitt<Events>();
</file>

<file path="src/replay/controller.ts">
import type { Dialogue } from "../../shared/schemas";
import { bus } from "./bus";

const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function computeDelay(mdx: string) {
  const words = mdx.split(/\s+/).length;

  // Base delay + reading time
  const base = 800; // minimum pause
  const perWord = 25; // reading pacing

  return base + words * perWord;
}

export async function replayDialogue(dialogue: Dialogue) {
  bus.emit("REPLAY_START");

  for (const turn of dialogue.turns) {
    bus.emit("APPEND_TURN", turn);

    const delay = computeDelay(turn.mdx);

    await sleep(delay);
  }

  bus.emit("REPLAY_COMPLETE");
}
</file>

<file path="flake.nix">
{
  description = "Platform-independent Bun + Vite dev shell with pre-commit hooks";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    git-hooks.url = "github:cachix/git-hooks.nix";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
      git-hooks,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };

        preCommit = git-hooks.lib.${system}.run {
          src = ./.;
          hooks = {
            # Secret scanning
            trufflehog.enable = true;
            ripsecrets.enable = true;

            # Nice hygiene
            nixfmt.enable = true;
            end-of-file-fixer.enable = true;
            trim-trailing-whitespace.enable = true;
          };
        };
      in
      {
        checks.pre-commit-check = preCommit;

        devShells.default = pkgs.mkShell {
          packages = [
            pkgs.bun
          ]
          ++ preCommit.enabledPackages;

          shellHook = ''
            ${preCommit.shellHook}
          '';
        };
      }
    );
}
</file>

<file path="shared/schemas.ts">
// shared/schemas.ts
import { z } from "zod";

/**
 * Prompt Input
 */
export const PromptRequestSchema = z.object({
  prompt: z.string().min(1),
});

/**
 * Speakers
 */
export const SpeakerSchema = z.enum([
  "security_engineer",
  "application_engineer",
]);

export type Speaker = z.infer<typeof SpeakerSchema>;

/**
 * A single conversational turn.
 * mdx is markdown/MDX-ish content (we'll render as markdown).
 * Mermaid diagrams are expressed as ```mermaid code fences inside mdx.
 */
export const TurnSchema = z.object({
  speaker: SpeakerSchema,
  mdx: z.string().min(1),
});

export type Turn = z.infer<typeof TurnSchema>;

/**
 * Dialogue root
 */
export const DialogueSchema = z.object({
  topic: z.string().min(1),
  turns: z.array(TurnSchema).min(6).max(12),
});

export type Dialogue = z.infer<typeof DialogueSchema>;
</file>

<file path="src/components/Pane.tsx">
import React, { useEffect, useRef } from "react";
import { Box, Text } from "@chakra-ui/react";
import { MdxRenderer } from "./MdxRenderer";
import { bus } from "../replay/bus";

export type LayoutBlock = {
  id: string;
  speaker: "security" | "application";
  mdx: string;
  height?: number;
};

export function Pane({
  kind,
  title,
  blocks,
}: {
  kind: "security" | "application";
  title: string;
  blocks: LayoutBlock[];
}) {
  return (
    <Box
      display="flex"
      flexDirection="column"
      minH="0"
      borderRightWidth={kind === "security" ? "1px" : undefined}
    >
      {/* Title */}
      <Box px="4" py="2" borderBottomWidth="1px" flexShrink={0}>
        <Text
          fontSize="xs"
          textTransform="uppercase"
          letterSpacing="wide"
          color="fg.muted"
        >
          {title}
        </Text>
      </Box>

      {/* Content */}
      <Box flex="1" minH="0" px="4" py="3">
        {blocks.map((block) => {
          const isMine = block.speaker === kind;

          return (
            <Box key={block.id} mb="3">
              {isMine ? (
                <MeasuredBubble id={block.id} content={block.mdx} />
              ) : (
                // Spacer mirrors measured height
                <Box height={block.height ? `${block.height}px` : "0px"} />
              )}
            </Box>
          );
        })}
      </Box>
    </Box>
  );
}

function MeasuredBubble({ id, content }: { id: string; content: string }) {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (!ref.current) return;

    const height = ref.current.offsetHeight;

    bus.emit("TURN_RENDERED", {
      id,
      height,
    });
  }, [id]);

  return (
    <Box
      ref={ref}
      maxW="90%"
      borderWidth="1px"
      borderRadius="md"
      px="3"
      py="2"
      fontSize="sm"
      lineHeight="1.5"
    >
      <MdxRenderer content={content} />
    </Box>
  );
}
</file>

<file path="package.json">
{
  "name": "socratic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev:server": "bun --watch server.ts",
    "dev:client": "vite",
    "dev": "concurrently -k -n server,client -c blue,green \"bun run dev:server\" \"bun run dev:client\""
  },
  "devDependencies": {
    "@types/bun": "latest",
    "@types/react": "^19.2.14",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.4",
    "concurrently": "^9.2.1",
    "vite": "^7.3.1"
  },
  "peerDependencies": {
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@chakra-ui/react": "^3.33.0",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "framer-motion": "^12.34.3",
    "mermaid": "^11.12.3",
    "mitt": "^3.0.1",
    "openai": "^6.24.0",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "react-markdown": "^10.1.0",
    "rehype-mermaid": "^3.0.0",
    "rehype-stringify": "^10.0.1",
    "remark-gfm": "^4.0.1",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "unified": "^11.0.5",
    "zod": "^4.3.6"
  }
}
</file>

<file path="server.ts">
import { OpenAI } from "openai";
import { zodTextFormat } from "openai/helpers/zod";
import { PromptRequestSchema, DialogueSchema } from "./shared/schemas";
import { mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const SYSTEM = `
You generate a structured architectural debate between two engineer archetypes.

Return JSON that matches the provided schema exactly.

STRUCTURE:
- topic: string
- turns: array of objects
    - speaker: "security_engineer" | "application_engineer"
    - mdx: string (valid markdown / MDX content)

CONVERSATION RULES:
- The first turn must be from "security_engineer".
- Speakers must strictly alternate.
- Each speaker must contribute 3–5 turns.
- Total turns: 6–10.
- The debate must include real disagreement and trade-offs.
- Avoid generic statements.

CONTENT RULES:
- The "mdx" field must contain valid markdown.
- Allowed markdown constructs:
    - paragraphs
    - bullet lists
    - headings
    - fenced code blocks
    - mermaid fenced diagrams
- Do not include markdown fences outside the mdx string.
- Do not include commentary outside the JSON response.
- Do not include extra keys.

MERMAID RULES:
- If including a diagram, use a fenced code block with language "mermaid".
- Always begin diagrams with: flowchart LR
- Keep diagrams minimal.
- Do not use:
    - click directives
    - classDef
    - note over
    - sequenceDiagram
- Ensure valid Mermaid syntax.

STYLE:
- Technical but concise.
- Cite concrete mechanisms (e.g., SPIFFE, OPA, gateways, rollout modes, failure cases).
- Each turn should respond directly to the previous one.
`.trim();

function json(data: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(data), {
    headers: { "content-type": "application/json" },
    ...init,
  });
}

function writeFixture(dialogue: unknown) {
  const path = "./src/fixtures/dialogue.json";
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, JSON.stringify(dialogue, null, 2), "utf-8");
}

async function handleDialogue(req: Request) {
  const body = PromptRequestSchema.parse(await req.json());

  const start = performance.now();

  const response = await client.responses.parse({
    model: "gpt-5-mini",
    input: [
      { role: "system", content: SYSTEM },
      { role: "user", content: `Topic: ${body.prompt}` },
    ],
    text: {
      format: zodTextFormat(DialogueSchema, "dialogue"),
    },
  });

  const duration = performance.now() - start;

  const parsed = DialogueSchema.parse(response.output_parsed);

  // Minimal but useful logging
  console.log(
    `[openai] model=${response.model} ` +
      `latency=${duration.toFixed(0)}ms ` +
      `tokens=${response.usage?.total_tokens ?? "?"}`,
  );

  writeFixture(parsed);

  return json(parsed);
}

Bun.serve({
  port: 3001,
  async fetch(req) {
    const url = new URL(req.url);

    if (url.pathname === "/api/dialogue") {
      if (req.method !== "POST") {
        return new Response("Method Not Allowed", { status: 405 });
      }

      try {
        return await handleDialogue(req);
      } catch (e) {
        return json(
          { error: e instanceof Error ? e.message : String(e) },
          { status: 400 },
        );
      }
    }

    return new Response("Not Found", { status: 404 });
  },
});
</file>

<file path="src/App.tsx">
import React, { useEffect, useRef, useState } from "react";
import { Box, Button, Input, Text } from "@chakra-ui/react";
import {
  PromptRequestSchema,
  DialogueSchema,
  type Dialogue,
  type Turn,
} from "../shared/schemas";
import { replayDialogue } from "./replay/controller";
import { bus } from "./replay/bus";
import fixtureData from "./fixtures/dialogue.json";
import { MdxRenderer } from "./components/MdxRenderer";

const USE_STATIC_FIXTURE = true;

type LayoutBlock = {
  id: string;
  speaker: "security" | "application";
  mdx: string;
  height?: number;
};

function mapSpeaker(s: Turn["speaker"]): "security" | "application" {
  return s === "security_engineer" ? "security" : "application";
}

export function App() {
  const [prompt, setPrompt] = useState("Zero trust in microservices");
  const [dialogue, setDialogue] = useState<Dialogue | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [blocks, setBlocks] = useState<LayoutBlock[]>([]);

  const scrollRef = useRef<HTMLDivElement | null>(null);

  async function generate() {
    setLoading(true);
    setError(null);

    try {
      let parsed: Dialogue;

      if (USE_STATIC_FIXTURE) {
        parsed = DialogueSchema.parse(fixtureData);
      } else {
        const body = PromptRequestSchema.parse({
          prompt,
        });

        const resp = await fetch("/api/dialogue", {
          method: "POST",
          headers: {
            "content-type": "application/json",
          },
          body: JSON.stringify(body),
        });

        if (!resp.ok) throw new Error(await resp.text());

        parsed = DialogueSchema.parse(await resp.json());
      }

      setDialogue(parsed);
    } catch (e) {
      setError(e instanceof Error ? e.message : String(e));
      setDialogue(null);
    } finally {
      setLoading(false);
    }
  }

  async function replay() {
    if (!dialogue) return;
    await replayDialogue(dialogue);
  }

  useEffect(() => {
    function onStart() {
      setBlocks([]);
    }

    function onAppend(turn: Turn) {
      setBlocks((prev) => [
        ...prev,
        {
          id: crypto.randomUUID(),
          speaker: mapSpeaker(turn.speaker),
          mdx: turn.mdx,
        },
      ]);
    }

    function onRendered({ id, height }: { id: string; height: number }) {
      setBlocks((prev) =>
        prev.map((b) => (b.id === id ? { ...b, height } : b)),
      );
    }

    bus.on("REPLAY_START", onStart);
    bus.on("APPEND_TURN", onAppend);
    bus.on("TURN_RENDERED", onRendered);

    return () => {
      bus.off("REPLAY_START", onStart);
      bus.off("APPEND_TURN", onAppend);
      bus.off("TURN_RENDERED", onRendered);
    };
  }, []);

  useEffect(() => {
    if (dialogue) {
      replayDialogue(dialogue);
    }
  }, [dialogue]);

  const lastAppendedIdRef = useRef<string | null>(null);

  useEffect(() => {
    function onStart() {
      setBlocks([]);
      lastAppendedIdRef.current = null;
    }

    function onAppend(turn: Turn) {
      const id = crypto.randomUUID();

      lastAppendedIdRef.current = id;

      setBlocks((prev) => [
        ...prev,
        {
          id,
          speaker: mapSpeaker(turn.speaker),
          mdx: turn.mdx,
        },
      ]);
    }

    function onRendered({ id, height }: { id: string; height: number }) {
      setBlocks((prev) =>
        prev.map((b) => (b.id === id ? { ...b, height } : b)),
      );
    }

    bus.on("REPLAY_START", onStart);
    bus.on("APPEND_TURN", onAppend);
    bus.on("TURN_RENDERED", onRendered);

    return () => {
      bus.off("REPLAY_START", onStart);
      bus.off("APPEND_TURN", onAppend);
      bus.off("TURN_RENDERED", onRendered);
    };
  }, []);

  useEffect(() => {
    if (!lastAppendedIdRef.current) return;

    const el = scrollRef.current;
    if (!el) return;

    requestAnimationFrame(() => {
      el.scrollTo({
        top: el.scrollHeight,
        behavior: "smooth",
      });
    });
  }, [blocks]);

  return (
    <Box
      height="100vh"
      display="flex"
      flexDirection="column"
      bg="bg"
      color="fg"
    >
      {/* Prompt Bar */}
      <Box
        px="6"
        py="3"
        borderBottomWidth="1px"
        display="flex"
        gap="3"
        flexShrink={0}
      >
        <Input value={prompt} onChange={(e) => setPrompt(e.target.value)} />

        <Button colorScheme="blue" onClick={generate} isLoading={loading}>
          Generate
        </Button>

        <Button variant="outline" onClick={replay} disabled={!dialogue}>
          Replay
        </Button>
      </Box>

      {/* Debate Surface */}
      <Box ref={scrollRef} flex="1" overflowY="auto" minH="0">
        {blocks.map((block) => (
          <TurnRow key={block.id} block={block} />
        ))}
      </Box>
    </Box>
  );
}

function TurnRow({ block }: { block: LayoutBlock }) {
  return (
    <Box display="grid" gridTemplateColumns="1fr 1fr" px="4" py="2">
      <Box>
        {block.speaker === "security" ? (
          <MeasuredBubble id={block.id} content={block.mdx} />
        ) : (
          <Box height={block.height ? `${block.height}px` : "0px"} />
        )}
      </Box>

      <Box>
        {block.speaker === "application" ? (
          <MeasuredBubble id={block.id} content={block.mdx} />
        ) : (
          <Box height={block.height ? `${block.height}px` : "0px"} />
        )}
      </Box>
    </Box>
  );
}

function MeasuredBubble({ id, content }: { id: string; content: string }) {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (!ref.current) return;

    const el = ref.current;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const height = entry.contentRect.height;

        bus.emit("TURN_RENDERED", {
          id,
          height,
        });
      }
    });

    observer.observe(el);

    return () => {
      observer.disconnect();
    };
  }, [id]);

  return (
    <Box
      ref={ref}
      maxW="90%"
      borderWidth="1px"
      borderRadius="md"
      px="3"
      py="2"
      fontSize="sm"
      lineHeight="1.5"
    >
      <MdxRenderer content={content} />
    </Box>
  );
}
</file>

</files>
