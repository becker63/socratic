This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shared/
  schemas.ts
src/
  components/
    MdxRenderer.tsx
  fixtures/
    dialogue.json
  hooks/
    useAutoScroll.ts
    useDebate.ts
    useDebateProjection.ts
    useGradientProjection.ts
    useLayoutStable.ts
    useObserverAnchor.ts
    useScrollOwnership.ts
  App.tsx
  bus.ts
  debateMachine.ts
  main.tsx
  replay.ts
  testBridge.ts
test-results/
  .last-run.json
tests/
  scroll.spec.ts
.gitignore
flake.lock
flake.nix
index.html
index.ts
package.json
playwright.config.ts
server.ts
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/hooks/useAutoScroll.ts">
import { useLayoutEffect, useRef } from "react";

export function useAutoScroll(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  blocksLength: number,
  scrollOwner: "machineOwned" | "userOwned",
  layoutReady: boolean,
) {
  const prevLengthRef = useRef(blocksLength);
  const pendingScrollRef = useRef(false);
  const restoringRef = useRef(false);

  useLayoutEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    if (blocksLength !== prevLengthRef.current) {
      prevLengthRef.current = blocksLength;

      if (scrollOwner === "machineOwned") {
        pendingScrollRef.current = true;
      }
    }

    if (layoutReady && pendingScrollRef.current) {
      restoringRef.current = true;
      el.scrollTop = el.scrollHeight;
      el.dispatchEvent(new Event("scroll")); // ensure ownership recalculates

      restoringRef.current = false;
      pendingScrollRef.current = false;
    }
  }, [blocksLength, layoutReady, scrollOwner]);

  return restoringRef;
}
</file>

<file path="src/hooks/useGradientProjection.ts">
// src/hooks/useGradientProjection.ts
import { useEffect, useState } from "react";
import type { ObserverMetrics } from "./useObserverAnchor";

export function useGradientProjection(
  observerMetrics: ObserverMetrics | null,
  layoutReady: boolean,
  maxDistance: number = 400,
) {
  const [intensity, setIntensity] = useState(0);
  const [normalizedPosition, setNormalizedPosition] = useState(0);

  useEffect(() => {
    if (!layoutReady || !observerMetrics) return;

    const { midYInViewport, viewportHeight } = observerMetrics;

    const distanceFromViewportBottom = viewportHeight - midYInViewport;

    const normalized = Math.max(
      0,
      Math.min(distanceFromViewportBottom / maxDistance, 1),
    );

    // cubic ease-out
    const eased = 1 - Math.pow(1 - normalized, 3);

    setNormalizedPosition(normalized);
    setIntensity(eased);
  }, [observerMetrics, layoutReady, maxDistance]);

  return { intensity, normalizedPosition };
}
</file>

<file path="src/hooks/useLayoutStable.ts">
// src/hooks/useLayoutStable.ts
import { useEffect, useState } from "react";

export function useLayoutStable(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  blocks: unknown[],
  settleMs: number = 150,
) {
  const [ready, setReady] = useState(false);
  const [version, setVersion] = useState(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const content = el.firstElementChild as HTMLElement | null;
    if (!content) return;

    setReady(false);

    let timeout: number | null = null;

    const observer = new ResizeObserver(() => {
      if (timeout) window.clearTimeout(timeout);

      timeout = window.setTimeout(() => {
        setReady(true);
        setVersion((v) => v + 1);
      }, settleMs);
    });

    observer.observe(content);

    return () => {
      observer.disconnect();
      if (timeout) window.clearTimeout(timeout);
    };
  }, [scrollRef, blocks.length, settleMs]);

  return { ready, version };
}
</file>

<file path="src/hooks/useObserverAnchor.ts">
// src/hooks/useObserverAnchor.ts
import { useEffect, useRef, useState } from "react";

export type ObserverMetrics = {
  midYInViewport: number;
  bottomInContent: number;
  viewportHeight: number;
};

export function useObserverAnchor(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  layoutReady: boolean,
) {
  const observerRef = useRef<HTMLDivElement | null>(null);
  const [metrics, setMetrics] = useState<ObserverMetrics | null>(null);

  useEffect(() => {
    if (!layoutReady) return;

    const scroller = scrollRef.current;
    const observer = observerRef.current;

    if (!scroller || !observer) return;

    const update = () => {
      const scrollerRect = scroller.getBoundingClientRect();
      const observerRect = observer.getBoundingClientRect();

      const midYInViewport = observerRect.top + observerRect.height / 2;

      const bottomInContent = observer.offsetTop + observer.offsetHeight;

      const viewportHeight = scroller.clientHeight;

      setMetrics({
        midYInViewport,
        bottomInContent,
        viewportHeight,
      });
    };

    update();
    scroller.addEventListener("scroll", update, { passive: true });
    window.addEventListener("resize", update);

    return () => {
      scroller.removeEventListener("scroll", update);
      window.removeEventListener("resize", update);
    };
  }, [layoutReady, scrollRef]);

  return { observerRef, observerMetrics: metrics };
}
</file>

<file path="src/bus.ts">
import mitt from "mitt";
import type { Turn } from "../shared/schemas";

export type Pane = "security" | "application";

export type Events = {
  REPLAY_START: void;
  APPEND_TURN: Turn;
  REPLAY_COMPLETE: void;

  // NEW
  TURN_RENDERED: {
    id: string;
    height: number;
  };
};

export const bus = mitt<Events>();
</file>

<file path="src/testBridge.ts">
// src/testBridge.ts
import { bus } from "./bus";

export function installTestBridge() {
  if (!import.meta.env.DEV && import.meta.env.MODE !== "test") return;

  (window as any).__socratic = {
    emit: (type: string, payload?: any) => bus.emit(type as any, payload),

    machineEvents: [] as string[],

    onMachineEvent(type: string) {
      (window as any).__socratic.machineEvents.push(type);
    },
  };
}
</file>

<file path="test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path="tests/scroll.spec.ts">
import { test, expect } from "@playwright/test";
import type { Page } from "@playwright/test";
import type { Turn } from "../shared/schemas";

function turn(i: number): Turn {
  return {
    speaker: i % 2 === 0 ? "security_engineer" : "application_engineer",
    mdx: `Turn ${i}\n\n` + "word ".repeat(200),
  };
}

async function appendTurns(page: Page, count: number) {
  for (let i = 0; i < count; i++) {
    await page.evaluate((payload: Turn) => {
      (window as any).__socratic?.emit("APPEND_TURN", payload);
    }, turn(i));
  }
}

async function dumpScrollState(page: Page, label: string) {
  const state = await page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    return {
      scrollTop: el.scrollTop,
      clientHeight: el.clientHeight,
      scrollHeight: el.scrollHeight,
      atBottom: el.scrollTop + el.clientHeight >= el.scrollHeight - 5,
      owner: el.getAttribute("data-scroll-owner"),
    };
  });

  console.log(`\n[${label}]`, state);
}

async function manualScroll(page: Page, delta: number) {
  await page.evaluate((amount) => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    el.scrollTop += amount;
    el.dispatchEvent(new Event("scroll"));
  }, delta);
}

async function scrollToBottom(page: Page) {
  await page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    el.scrollTop = el.scrollHeight;
    el.dispatchEvent(new Event("scroll"));
  });
}

test.beforeEach(async ({ page }) => {
  page.on("console", (msg) => {
    console.log(`[browser:${msg.type()}]`, msg.text());
  });
});

/* ------------------------------------------------------------
   Fresh State
------------------------------------------------------------ */

test("fresh load starts machineOwned", async ({ page }) => {
  await page.goto("/");
  await dumpScrollState(page, "fresh load");

  const owner = await page
    .getByTestId("scroll-viewport")
    .getAttribute("data-scroll-owner");

  expect(owner).toBe("machineOwned");
});

/* ------------------------------------------------------------
   Auto-scroll behavior
------------------------------------------------------------ */

test("machineOwned auto-scrolls on append", async ({ page }) => {
  await page.goto("/");

  await appendTurns(page, 8);

  await expect
    .poll(async () =>
      page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner"),
    )
    .toBe("machineOwned");

  await dumpScrollState(page, "after append");

  await expect
    .poll(async () =>
      page.evaluate(() => {
        const el = document.querySelector(
          "[data-testid='scroll-viewport']",
        ) as HTMLElement;
        return el.scrollTop + el.clientHeight >= el.scrollHeight - 5;
      }),
    )
    .toBeTruthy();

  await dumpScrollState(page, "after auto-scroll settle");
});

test("machineOwned stays machineOwned when appending", async ({ page }) => {
  await page.goto("/");

  await appendTurns(page, 8);
  await appendTurns(page, 1);

  await dumpScrollState(page, "after second append");

  const owner = await page
    .getByTestId("scroll-viewport")
    .getAttribute("data-scroll-owner");

  expect(owner).toBe("machineOwned");
});

/* ------------------------------------------------------------
   Manual Scroll Behavior
------------------------------------------------------------ */

test("manual scroll up transitions to userOwned", async ({ page }) => {
  await page.goto("/");

  await appendTurns(page, 8);

  // Ensure starting at bottom
  await scrollToBottom(page);

  await manualScroll(page, -600);

  await dumpScrollState(page, "after manual scroll up");

  await expect
    .poll(async () =>
      page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner"),
    )
    .toBe("userOwned");

  await dumpScrollState(page, "after ownership transition");
});

test("userOwned remains userOwned when appending", async ({ page }) => {
  await page.goto("/");

  await appendTurns(page, 8);

  await scrollToBottom(page);
  await manualScroll(page, -600);

  await expect
    .poll(async () =>
      page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner"),
    )
    .toBe("userOwned");

  await appendTurns(page, 1);

  await dumpScrollState(page, "after append while userOwned");

  const owner = await page
    .getByTestId("scroll-viewport")
    .getAttribute("data-scroll-owner");

  expect(owner).toBe("userOwned");
});

/* ------------------------------------------------------------
   Returning to bottom
------------------------------------------------------------ */

test("scrolling back to bottom transitions to machineOwned", async ({
  page,
}) => {
  await page.goto("/");

  await appendTurns(page, 8);

  await scrollToBottom(page);
  await manualScroll(page, -600);

  await expect
    .poll(async () =>
      page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner"),
    )
    .toBe("userOwned");

  await dumpScrollState(page, "after scroll up");

  await scrollToBottom(page);

  await dumpScrollState(page, "after scroll to bottom");

  await expect
    .poll(async () =>
      page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner"),
    )
    .toBe("machineOwned");

  await dumpScrollState(page, "final state");
});
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="index.html">
<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Minimal Bun + React</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
</file>

<file path="index.ts">
console.log("Hello via Bun!");
</file>

<file path="playwright.config.ts">
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./tests",
  timeout: 30_000,
  use: {
    headless: true,
    baseURL: "http://127.0.0.1:5173",
    browserName: "chromium",
    launchOptions: {
      executablePath: process.env.PLAYWRIGHT_CHROMIUM_PATH,
    },
  },
  webServer: {
    command: "bunx vite --host 127.0.0.1 --port 5173",
    url: "http://127.0.0.1:5173",
    reuseExistingServer: !process.env.CI,
    timeout: 60_000,
  },
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "moduleDetection": "force",
    "verbatimModuleSyntax": true,
    "allowImportingTsExtensions": true,

    "noEmit": true,

    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  },
  "include": ["src", "shared", "server.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001",
    },
  },
});
</file>

<file path="src/fixtures/dialogue.json">
{
  "topic": "Zero trust in microservices",
  "turns": [
    {
      "speaker": "security_engineer",
      "mdx": "We should adopt a strict zero-trust posture for east‑west traffic using workload identities (SPIFFE), mTLS between sidecars, and OPA for fine‑grained policy enforcement.\n\nKey points:\n\n- Authenticate by identity, not network: SPIFFE SVIDs issued by SPIRE; short‑lived X.509 (or JWT‑SVID) for revocation-free rotation.\n- Encrypt and authorize at the edge of the workload: Envoy/sidecar mTLS, Envoy RBAC + OPA as an external authorizer.\n- Deny‑by‑default RBAC and attribute‑based policies (OPA/Rego) for sensitive calls (database, secrets manager).\n- Rollout strategy: permissive mTLS -> canary (5–25%) -> all, and use chaos engineering to verify cert expiry recovery paths.\n\nConcrete failure cases to prepare for:\n\n- SPIRE control plane compromise: have offline root CA and automated rotation playbooks.\n- Certificate expiry or network partition: use permissive mode with strict audit for short windows and automatic restart/renewal agents.\n\nI expect pushback on complexity and latency; I’ll address trade‑offs if you outline those concerns."
    },
    {
      "speaker": "application_engineer",
      "mdx": "I agree with identity‑first goals, but I push back on mandatory sidecars + Envoy for every service because of operational and performance costs.\n\nProblems I see:\n\n- CPU and latency: Envoy sidecars add p99 tail latency and ~5–15% CPU overhead in polyglot fleets.\n- Integration friction: not every runtime team can embed SPIFFE SDKs; sidecars can be heavy for small services (FaaS/edge devices).\n- Centralized OPA policies become deployment coupling: a policy change can break many services and slow down releases.\n\nA pragmatic alternative I propose:\n\n- North‑south: API gateway enforces strong auth (JWT introspection, rate limiting, WAF). Use token caches and introspection caching.\n- East‑west hybrid: critical services use SPIFFE mTLS; noncritical internal calls use signed JWTs with short TTL + local verification.\n- Gradual rollout: start gateway + JWTs, then progressively onboard service mesh for high‑risk paths.\n\nI want to see concrete latency measurements and rollout knobs before committing cluster‑wide sidecars."
    },
    {
      "speaker": "security_engineer",
      "mdx": "Good points — latency and operational burden are real. Still, JWTs and gateway‑only enforcement have concrete attack windows:\n\n- Replay and revocation: long‑lived JWTs are hard to revoke; token introspection adds central dependency and latency spikes.\n- Gateway compromise: a single compromised ingress gateway could mint or forward tokens to east‑west paths if we rely on gateway trust alone.\n\nHow we mitigate while addressing your concerns:\n\n- Use SPIFFE short‑lived SVIDs (X.509 or JWT‑SVID). TTLs of 10–30 minutes eliminate long revocation windows and avoid introspection for every call.\n- Reduce sidecar overhead: leverage eBPF or kernel bypass (Envoy’s XDP/AF_XDP or gVisor bypass patterns) for hot paths; restrict full proxy to critical services.\n- Rollout concretely:\n  - Phase 1: deploy SPIRE server + agents on control plane nodes; run Envoy in permissive mode (mTLS verified but not required) for 2 weeks.\n  - Phase 2: canary 5% of services with enforced mTLS and OPA policies; monitor p99 auth latency, CPU delta, and error rate.\n  - Phase 3: expand by risk category.\n\nFailure/callback plan:\n\n- If SPIRE unavailable, agents continue serving cached SVIDs until expiry; set TTLs short but long enough to survive brief outages (e.g., 15m).\n- For wider outages, auto‑rollback to permissive with strict logging and alerts, not fail‑open permanently."
    },
    {
      "speaker": "application_engineer",
      "mdx": "Accepting JWT replay concerns and the SPIFFE short‑lived solution helps. Still, the devil is in operational details and developer velocity.\n\nOperational trade‑offs I want addressed before full adoption:\n\n- SDK vs sidecar: SDKs avoid heavy sidecars but create language‑specific maintenance across many teams. Sidecars centralize complexity but hurt resource budgets.\n- Observability/perf KPIs: we need concrete thresholds before canary expansion (acceptable p99 increase, CPU budget per pod, memory).\n- Policy ownership: OPA as a centralized policy store needs guardrails (policy review workflow, testing harnesses).\n\nProposed hybrid implementation to compromise:\n\n- Use SPIRE agents + sidecars for critical, high‑risk services (payments, auth, db proxies).\n- Use JWT‑SVID (SPIFFE supports JWT‑SVID) for lightweight validation in low‑risk services — apps validate locally with a stable public key bundle.\n- Deploy OPA as a local sidecar for low latency but keep a central OPA server for policy authorship and CI testing; use policy signing and automated promotion.\n\nAlso, we should create canary KPIs: start at 5% traffic, expand if p99 auth latency delta <2ms and CPU overhead <5%."
    },
    {
      "speaker": "security_engineer",
      "mdx": "I like the hybrid shape and it's consistent with SPIFFE capabilities. A few concrete mechanisms and operational controls I insist on:\n\n- Use JWT‑SVIDs where appropriate: SPIRE issues JWT‑SVIDs so apps can validate tokens offline using the trust bundle (no introspection). This addresses your SDK concern without sacrificing short TTLs.\n- Policy enforcement: use Envoy RBAC + OPA plugin for complex attribute logic; OPA Gatekeeper for K8s admission controls to stop misconfigurations.\n- Failover and TTL specifics:\n  - Certificate/SVID TTL: 10–30 minutes (trade‑off: shorter TTL reduces compromise window but increases issuance load).\n  - SPIRE HA: run SPIRE server as an HA set; monitor issuance latency and queue length; alert at issuance latency >500ms or queue >1000.\n- Rollback strategy: permissive mode with strict audit for a maximum window (e.g., 4 hours) and automated rollback if:\n  - p99 auth latency increases >2ms above baseline, or\n  - request error rate increases by >1% absolute, or\n  - CPU overhead >7% on canary pods.\n\nMinimal diagram of the flow:\n\n```mermaid\nflowchart LR\n  A[workload] -->|fetch SVID| B[SPIRE agent]\n  A -->|mTLS| C[sidecar Envoy]\n  C -->|policy check| D[OPA sidecar]\n  D --> E[target service]\n```\n\nI’ll own SPIRE outage playbooks and automated alerts if we agree on the KPI thresholds above."
    },
    {
      "speaker": "application_engineer",
      "mdx": "That diagram and the concrete thresholds make the plan actionable. I accept the hybrid architecture provided we lock down these operational SLAs and automation steps:\n\n- KPIs and rollout gates:\n  - Canary progression: 5% -> 25% -> 100% when p99 auth latency delta <= 2ms and CPU overhead <= 5%.\n  - If error rate increases >1% or auth failures >0.1% for 10 minutes, auto‑rollback to permissive for affected canaries.\n- Performance mitigations:\n  - Use eBPF for in‑kernel fast path where possible and an Envoy wasm filter for lightweight policy checks.\n  - Cache public bundles for JWT‑SVID validation, refresh off‑peak.\n- Responsibilities:\n  - Security owns SPIRE HA, TTL tuning, and automated rollback playbooks.\n  - Platform owns sidecar deployment patterns, eBPF integration, and a policy CI that validates Rego on test traffic.\n\nIf you commit to those duties and the canary gates, I’ll start a pilot with three critical services and measure metrics for two weeks before broader rollout."
    }
  ]
}
</file>

<file path="src/hooks/useDebate.ts">
import { useState } from "react";
import { useMachine } from "@xstate/react";
import {
  PromptRequestSchema,
  DialogueSchema,
  type Dialogue,
} from "../../shared/schemas";
import fixtureData from "../fixtures/dialogue.json";
import { debateMachine } from "../debateMachine";

const USE_STATIC_FIXTURE = true;

export function useDebate(inspect?: any) {
  const [prompt, setPrompt] = useState("Zero trust in microservices");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [state, send] = useMachine(debateMachine, {
    inspect,
  });

  async function generate() {
    setLoading(true);
    setError(null);

    try {
      let parsed: Dialogue;

      if (USE_STATIC_FIXTURE) {
        parsed = DialogueSchema.parse(fixtureData);
      } else {
        const body = PromptRequestSchema.parse({ prompt });

        const resp = await fetch("/api/dialogue", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(body),
        });

        if (!resp.ok) throw new Error(await resp.text());

        parsed = DialogueSchema.parse(await resp.json());
      }

      send({ type: "GENERATE", dialogue: parsed });
    } catch (e) {
      setError(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  }

  function replay() {
    send({ type: "REPLAY" });
  }

  return {
    prompt,
    setPrompt,
    loading,
    error,
    send,
    state,
    generate,
    replay,
  };
}
</file>

<file path="src/hooks/useDebateProjection.ts">
import { useEffect, useState } from "react";
import type { Turn } from "../../shared/schemas";
import { bus } from "../bus";

export type LayoutBlock = Turn & {
  id: string;
  height?: number;
};

export function useDebateProjection() {
  const [blocks, setBlocks] = useState<LayoutBlock[]>([]);

  useEffect(() => {
    function onStart() {
      setBlocks([]);
    }

    function onAppend(turn: Turn) {
      setBlocks((prev) => [
        ...prev,
        {
          ...turn,
          id: crypto.randomUUID(),
        },
      ]);
    }

    function onRendered({ id, height }: { id: string; height: number }) {
      setBlocks((prev) =>
        prev.map((b) => (b.id === id ? { ...b, height } : b)),
      );
    }

    bus.on("REPLAY_START", onStart);
    bus.on("APPEND_TURN", onAppend);
    bus.on("TURN_RENDERED", onRendered);

    return () => {
      bus.off("REPLAY_START", onStart);
      bus.off("APPEND_TURN", onAppend);
      bus.off("TURN_RENDERED", onRendered);
    };
  }, []);

  return blocks;
}
</file>

<file path="src/hooks/useScrollOwnership.ts">
import { useEffect, useRef } from "react";
import type { AnyActorRef } from "xstate";

export function useScrollOwnership(
  send: AnyActorRef["send"],
  scrollRef: React.RefObject<HTMLDivElement | null>,
  restoringRef: React.MutableRefObject<boolean>,
) {
  const lastAtBottomRef = useRef<boolean | null>(null);
  const lastScrollTopRef = useRef<number>(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const checkOwnership = () => {
      const currentScrollTop = el.scrollTop;
      const atBottom =
        currentScrollTop + el.clientHeight >= el.scrollHeight - 5;

      const scrollingUp = currentScrollTop < lastScrollTopRef.current;
      const scrollingDown = currentScrollTop > lastScrollTopRef.current;

      console.log("[ownership check]", {
        scrollTop: currentScrollTop,
        clientHeight: el.clientHeight,
        scrollHeight: el.scrollHeight,
        atBottom,
        restoring: restoringRef.current,
        lastAtBottom: lastAtBottomRef.current,
        scrollingUp,
        scrollingDown,
      });

      // Update scrollTop tracker immediately
      lastScrollTopRef.current = currentScrollTop;

      // Ignore machine-driven scroll restoration
      if (restoringRef.current) return;

      // If user actively scrolled upward and we are no longer at bottom
      if (!atBottom && scrollingUp) {
        if (lastAtBottomRef.current !== false) {
          lastAtBottomRef.current = false;
          send({ type: "USER_SCROLLED_UP" });
        }
        return;
      }

      // If we reached bottom (either via user scroll down or auto-scroll)
      if (atBottom) {
        if (lastAtBottomRef.current !== true) {
          lastAtBottomRef.current = true;
          send({ type: "USER_AT_BOTTOM" });
        }
      }
    };

    el.addEventListener("scroll", checkOwnership, { passive: true });

    // Initialize tracking state
    lastScrollTopRef.current = el.scrollTop;
    lastAtBottomRef.current =
      el.scrollTop + el.clientHeight >= el.scrollHeight - 5;

    checkOwnership();

    return () => {
      el.removeEventListener("scroll", checkOwnership);
    };
  }, [send, scrollRef, restoringRef]);
}
</file>

<file path="src/debateMachine.ts">
// src/machines/debateMachine.ts
import { setup, assign, fromPromise } from "xstate";
import type { Dialogue } from "../shared/schemas";
import { replayDialogue } from "./replay";

/* ------------------------------------------------------------
   Utilities
------------------------------------------------------------ */

function now() {
  return typeof performance !== "undefined"
    ? performance.now().toFixed(2)
    : Date.now();
}

function emitTestEvent(type: string, payload?: any) {
  if (typeof window !== "undefined") {
    const w = window as any;
    if (w.__socratic?.onMachineEvent) {
      w.__socratic.onMachineEvent({ type, payload });
    }
  }
}

function deepClone<T>(v: T): T {
  return JSON.parse(JSON.stringify(v));
}

/* ------------------------------------------------------------
   Machine
------------------------------------------------------------ */

export const debateMachine = setup({
  types: {
    context: {} as {
      dialogue: Dialogue | null;
      error: string | null;
    },
    events: {} as
      | { type: "GENERATE"; dialogue: Dialogue }
      | { type: "REPLAY" }
      | { type: "USER_SCROLLED_UP" }
      | { type: "USER_AT_BOTTOM" }
      | { type: "FAIL"; error: string },
  },

  /* ------------------------------------------------------------
     Global Instrumentation
  ------------------------------------------------------------ */

  actions: {
    logTransition: ({ context, event, self }) => {
      const snapshot = self.getSnapshot();

      const lifecycleState =
        typeof snapshot.value === "object" && "lifecycle" in snapshot.value
          ? snapshot.value.lifecycle
          : snapshot.value;

      const scrollState =
        typeof snapshot.value === "object" && "scroll" in snapshot.value
          ? snapshot.value.scroll
          : null;

      const logPayload = {
        t: now(),
        event: event.type,
        lifecycle: lifecycleState,
        scroll: scrollState,
        context: deepClone(context),
      };

      console.log("[machine transition]", logPayload);
      emitTestEvent("TRANSITION", logPayload);
    },

    logUserAtBottom: ({ context }) => {
      const payload = {
        t: now(),
        type: "USER_AT_BOTTOM",
        context: deepClone(context),
      };
      console.log("[machine] USER_AT_BOTTOM", payload);
      emitTestEvent("USER_AT_BOTTOM", payload);
    },

    logUserScrolledUp: ({ context }) => {
      const payload = {
        t: now(),
        type: "USER_SCROLLED_UP",
        context: deepClone(context),
      };
      console.log("[machine] USER_SCROLLED_UP", payload);
      emitTestEvent("USER_SCROLLED_UP", payload);
    },
  },

  actors: {
    replayActor: fromPromise(
      async ({ input }: { input: { dialogue: Dialogue } }) => {
        console.log("[machine] replayActor invoked", {
          t: now(),
          turns: input.dialogue.turns.length,
        });

        await replayDialogue(input.dialogue);

        console.log("[machine] replayActor completed", {
          t: now(),
        });
      },
    ),
  },
}).createMachine({
  id: "debate",
  type: "parallel",

  context: {
    dialogue: null,
    error: null,
  },

  states: {
    lifecycle: {
      initial: "idle",

      states: {
        idle: {
          entry: "logTransition",

          on: {
            GENERATE: {
              target: "ready",
              actions: [
                assign({
                  dialogue: ({ event }) => event.dialogue,
                  error: () => null,
                }),
                "logTransition",
              ],
            },
          },
        },

        ready: {
          entry: "logTransition",

          on: {
            REPLAY: {
              target: "replaying",
              actions: "logTransition",
            },
          },
        },

        replaying: {
          entry: "logTransition",

          invoke: {
            src: "replayActor",
            input: ({ context }) => {
              if (!context.dialogue) {
                throw new Error("No dialogue available");
              }
              return { dialogue: context.dialogue };
            },
            onDone: {
              target: "complete",
              actions: "logTransition",
            },
            onError: {
              target: "error",
              actions: [
                assign({
                  error: ({ event }) => String(event.error),
                }),
                "logTransition",
              ],
            },
          },
        },

        complete: {
          entry: "logTransition",

          on: {
            REPLAY: {
              target: "replaying",
              actions: "logTransition",
            },
          },
        },

        error: {
          entry: "logTransition",

          on: {
            GENERATE: {
              target: "ready",
              actions: [
                assign({
                  dialogue: ({ event }) => event.dialogue,
                  error: () => null,
                }),
                "logTransition",
              ],
            },
          },
        },
      },
    },

    scroll: {
      initial: "machineOwned",

      states: {
        machineOwned: {
          entry: "logTransition",

          on: {
            USER_SCROLLED_UP: {
              target: "userOwned",
              actions: ["logUserScrolledUp", "logTransition"],
            },
          },
        },

        userOwned: {
          entry: "logTransition",

          on: {
            USER_AT_BOTTOM: {
              target: "machineOwned",
              actions: ["logUserAtBottom", "logTransition"],
            },
          },
        },
      },
    },
  },
});
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { ChakraProvider, defaultSystem } from "@chakra-ui/react";
import { App } from "./App";
import { installTestBridge } from "./testBridge";

let inspector: ReturnType<
  typeof import("@statelyai/inspect").createBrowserInspector
> | null = null;

if (import.meta.env.DEV) {
  const { createBrowserInspector } = await import("@statelyai/inspect");

  inspector = createBrowserInspector();
}

installTestBridge();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ChakraProvider value={defaultSystem}>
      <App inspector={inspector} />
    </ChakraProvider>
  </React.StrictMode>,
);
</file>

<file path="src/replay.ts">
import type { Dialogue } from "../shared/schemas";
import { bus } from "./bus";

const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function computeDelay(mdx: string) {
  const words = mdx.split(/\s+/).length;

  // Base delay + reading time
  const base = 800; // minimum pause
  const perWord = 25; // reading pacing

  return base + words * perWord;
}

export async function replayDialogue(dialogue: Dialogue) {
  bus.emit("REPLAY_START");

  for (const turn of dialogue.turns) {
    console.log("[bus] APPEND_TURN");
    bus.emit("APPEND_TURN", turn);

    const delay = computeDelay(turn.mdx);

    await sleep(delay);
  }

  bus.emit("REPLAY_COMPLETE");
}
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1767039857,
        "narHash": "sha256-vNpUSpF5Nuw8xvDLj2KCwwksIbjua2LZCqhV1LNRDns=",
        "owner": "NixOS",
        "repo": "flake-compat",
        "rev": "5edf11c44bc78a0d334f6334cdaf7d60d732daab",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "git-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1772024342,
        "narHash": "sha256-+eXlIc4/7dE6EcPs9a2DaSY3fTA9AE526hGqkNID3Wg=",
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "6e34e97ed9788b17796ee43ccdbaf871a5c2b476",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "git-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1770073757,
        "narHash": "sha256-Vy+G+F+3E/Tl+GMNgiHl9Pah2DgShmIUBJXmbiQPHbI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "47472570b1e607482890801aeaf29bfb749884f6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1771848320,
        "narHash": "sha256-0MAd+0mun3K/Ns8JATeHT1sX28faLII5hVLq0L3BdZU=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2fc6539b481e1d2569f25f8799236694180c0993",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "git-hooks": "git-hooks",
        "nixpkgs": "nixpkgs_2"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="shared/schemas.ts">
// shared/schemas.ts
import { z } from "zod";

/**
 * Prompt Input
 */
export const PromptRequestSchema = z.object({
  prompt: z.string().min(1),
});

/**
 * Speakers
 */
export const SpeakerSchema = z.enum([
  "security_engineer",
  "application_engineer",
]);

export type Speaker = z.infer<typeof SpeakerSchema>;

/**
 * A single conversational turn.
 * mdx is markdown/MDX-ish content (we'll render as markdown).
 * Mermaid diagrams are expressed as ```mermaid code fences inside mdx.
 */
export const TurnSchema = z.object({
  speaker: SpeakerSchema,
  mdx: z.string().min(1),
});

export type Turn = z.infer<typeof TurnSchema>;

/**
 * Dialogue root
 */
export const DialogueSchema = z.object({
  topic: z.string().min(1),
  turns: z.array(TurnSchema).min(6).max(12),
});

export type Dialogue = z.infer<typeof DialogueSchema>;
</file>

<file path="src/components/MdxRenderer.tsx">
import React from "react";
import { Box } from "@chakra-ui/react";
import { MarkdownHooks } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeMermaid from "rehype-mermaid";

export function MdxRenderer({ content }: { content: string }) {
  return (
    <Box
      css={{
        "& p": { marginBottom: "1rem", lineHeight: 1.8 },
        "& ul": { paddingLeft: "1.4rem", marginBottom: "1rem" },
        "& li": { marginBottom: "0.4rem" },
        "& pre": {
          background: "rgba(255,255,255,0.04)",
          padding: "1rem",
          borderRadius: "12px",
          border: "1px solid rgba(255,255,255,0.06)",
          overflowX: "auto",
          fontSize: "0.9rem",
        },
        "& code": {
          background: "rgba(255,255,255,0.08)",
          padding: "0.2rem 0.4rem",
          borderRadius: "6px",
        },
        "& svg": {
          background: "rgba(255,255,255,0.03)",
          borderRadius: "12px",
          padding: "0.5rem",
        },
      }}
    >
      <MarkdownHooks
        key={content}
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[[rehypeMermaid, { strategy: "inline-svg" }]]}
      >
        {content}
      </MarkdownHooks>
    </Box>
  );
}
</file>

<file path="flake.nix">
{
  description = "Bun + Vite + Playwright + Pre-commit multi-platform dev shell";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    git-hooks.url = "github:cachix/git-hooks.nix";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
      git-hooks,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };

        preCommit = git-hooks.lib.${system}.run {
          src = ./.;
          hooks = {
            # Secret scanning
            trufflehog.enable = true;
            ripsecrets.enable = true;

            # Hygiene
            nixfmt.enable = true;
            end-of-file-fixer.enable = true;
            trim-trailing-whitespace.enable = true;
          };
        };
      in
      {
        checks.pre-commit-check = preCommit;

        devShells.default = pkgs.mkShell {
          packages = [
            pkgs.bun
            pkgs.chromium
          ]
          ++ preCommit.enabledPackages;

          shellHook = ''
            ${preCommit.shellHook}

            export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
            export PLAYWRIGHT_CHROMIUM_PATH=${pkgs.chromium}/bin/chromium
            export PLAYWRIGHT_BROWSERS_PATH=0
          '';
        };
      }
    );
}
</file>

<file path="server.ts">
import { OpenAI } from "openai";
import { zodTextFormat } from "openai/helpers/zod";
import { PromptRequestSchema, DialogueSchema } from "./shared/schemas";
import { mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const SYSTEM = `
You generate a structured architectural debate between two engineer archetypes.

Return JSON that matches the provided schema exactly.

STRUCTURE:
- topic: string
- turns: array of objects
    - speaker: "security_engineer" | "application_engineer"
    - mdx: string (valid markdown / MDX content)

CONVERSATION RULES:
- The first turn must be from "security_engineer".
- Speakers must strictly alternate.
- Each speaker must contribute 3–5 turns.
- Total turns: 6–10.
- The debate must include real disagreement and trade-offs.
- Avoid generic statements.

CONTENT RULES:
- The "mdx" field must contain valid markdown.
- Allowed markdown constructs:
    - paragraphs
    - bullet lists
    - headings
    - fenced code blocks
    - mermaid fenced diagrams
- Do not include markdown fences outside the mdx string.
- Do not include commentary outside the JSON response.
- Do not include extra keys.

MERMAID RULES:
- If including a diagram, use a fenced code block with language "mermaid".
- Always begin diagrams with: flowchart LR
- Keep diagrams minimal.
- Do not use:
    - click directives
    - classDef
    - note over
    - sequenceDiagram
- Ensure valid Mermaid syntax.

STYLE:
- Technical but concise.
- Cite concrete mechanisms (e.g., SPIFFE, OPA, gateways, rollout modes, failure cases).
- Each turn should respond directly to the previous one.
`.trim();

function json(data: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(data), {
    headers: { "content-type": "application/json" },
    ...init,
  });
}

function writeFixture(dialogue: unknown) {
  const path = "./src/fixtures/dialogue.json";
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, JSON.stringify(dialogue, null, 2), "utf-8");
}

async function handleDialogue(req: Request) {
  const body = PromptRequestSchema.parse(await req.json());

  const start = performance.now();

  const response = await client.responses.parse({
    model: "gpt-5-mini",
    input: [
      { role: "system", content: SYSTEM },
      { role: "user", content: `Topic: ${body.prompt}` },
    ],
    text: {
      format: zodTextFormat(DialogueSchema, "dialogue"),
    },
  });

  const duration = performance.now() - start;

  const parsed = DialogueSchema.parse(response.output_parsed);

  // Minimal but useful logging
  console.log(
    `[openai] model=${response.model} ` +
      `latency=${duration.toFixed(0)}ms ` +
      `tokens=${response.usage?.total_tokens ?? "?"}`,
  );

  writeFixture(parsed);

  return json(parsed);
}

Bun.serve({
  port: 3001,
  async fetch(req) {
    const url = new URL(req.url);

    if (url.pathname === "/api/dialogue") {
      if (req.method !== "POST") {
        return new Response("Method Not Allowed", { status: 405 });
      }

      try {
        return await handleDialogue(req);
      } catch (e) {
        return json(
          { error: e instanceof Error ? e.message : String(e) },
          { status: 400 },
        );
      }
    }

    return new Response("Not Found", { status: 404 });
  },
});
</file>

<file path="package.json">
{
  "name": "socratic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev:server": "bun --watch server.ts",
    "dev:client": "vite",
    "dev": "concurrently -k -n server,client -c blue,green \"bun run dev:server\" \"bun run dev:client\"",
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:trace": "playwright test --trace on",
    "test:debug": "playwright test --debug"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@statelyai/inspect": "^0.4.0",
    "@types/bun": "latest",
    "@types/react": "^19.2.14",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.4",
    "concurrently": "^9.2.1",
    "vite": "^7.3.1"
  },
  "peerDependencies": {
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@chakra-ui/react": "^3.33.0",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@xstate/react": "^6.0.0",
    "framer-motion": "^12.34.3",
    "mermaid": "^11.12.3",
    "mitt": "^3.0.1",
    "openai": "^6.24.0",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "react-markdown": "^10.1.0",
    "rehype-mermaid": "^3.0.0",
    "rehype-stringify": "^10.0.1",
    "remark-gfm": "^4.0.1",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "unified": "^11.0.5",
    "xstate": "^5.28.0",
    "zod": "^4.3.6"
  }
}
</file>

<file path="src/App.tsx">
// src/App.tsx
import React from "react";
import { Box, Button, Input, Text } from "@chakra-ui/react";
import { motion } from "framer-motion";
import { useDebate } from "./hooks/useDebate";
import { useDebateProjection } from "./hooks/useDebateProjection";
import { useLayoutStable } from "./hooks/useLayoutStable";
import { useObserverAnchor } from "./hooks/useObserverAnchor";
import { useGradientProjection } from "./hooks/useGradientProjection";
import { useScrollOwnership } from "./hooks/useScrollOwnership";
import { useAutoScroll } from "./hooks/useAutoScroll";
import { MdxRenderer } from "./components/MdxRenderer";
import { bus } from "./bus";

const MotionBox = motion(Box);

export function App({ inspector }: { inspector?: any }) {
  const { prompt, setPrompt, loading, state, send, generate, replay } =
    useDebate(inspector?.inspect);

  const blocks = useDebateProjection();

  const scrollRef = React.useRef<HTMLDivElement | null>(null);

  // 1️⃣ Wait for layout (MDX + Mermaid) to stabilize
  const { ready: layoutReady } = useLayoutStable(scrollRef, blocks);

  // 2️⃣ Attach observer to bottom of content
  const { observerRef, observerMetrics } = useObserverAnchor(
    scrollRef,
    layoutReady,
  );

  // 3️⃣ Project observer geometry into gradient intensity
  const { intensity } = useGradientProjection(observerMetrics, layoutReady);

  // Extract scroll owner from state machine
  const scrollOwner =
    typeof state.value === "object" && "scroll" in state.value
      ? state.value.scroll
      : "machineOwned";

  // 4️⃣ Auto-scroll (returns restoringRef)
  const restoringRef = useAutoScroll(
    scrollRef,
    blocks.length,
    scrollOwner,
    layoutReady,
  );

  // 5️⃣ Ownership (suppressed while restoring)
  useScrollOwnership(send, scrollRef, restoringRef);

  return (
    <Box
      height="100vh"
      bg="#0d0f14"
      color="#e6e8ec"
      fontSize="17px"
      lineHeight="1.8"
      display="flex"
      flexDirection="column"
    >
      {/* Prompt Bar */}
      <Box
        position="sticky"
        top="0"
        zIndex="10"
        px="48px"
        py="20px"
        display="flex"
        gap="14px"
        backdropFilter="blur(12px)"
        bg="rgba(13,15,20,0.78)"
        borderBottom="1px solid rgba(255,255,255,0.05)"
      >
        <Input
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Zero trust in microservices…"
          bg="rgba(255,255,255,0.05)"
          border="1px solid rgba(255,255,255,0.08)"
          _focus={{ borderColor: "rgba(120,170,255,0.6)" }}
        />

        <Button
          onClick={generate}
          loading={loading}
          bg="rgba(255,255,255,0.08)"
          _hover={{ bg: "rgba(255,255,255,0.14)" }}
        >
          Generate
        </Button>

        <Button
          variant="outline"
          onClick={replay}
          disabled={!state.context.dialogue}
          border="1px solid rgba(255,255,255,0.1)"
        >
          Replay
        </Button>
      </Box>

      {/* Debate Stage Wrapper */}
      <Box flex="1" position="relative">
        {/* Scroll Viewport */}
        <Box
          ref={scrollRef}
          position="absolute"
          inset="0"
          overflowY="auto"
          data-testid="scroll-viewport"
          data-layout-ready={layoutReady ? "true" : "false"}
          data-scroll-owner={state.value.scroll}
        >
          {/* Content Wrapper */}
          <Box pt="160px" pb="160px">
            {blocks.map((block, i) => (
              <TurnRow key={block.id} block={block} index={i} />
            ))}

            {/* 2️⃣ Observer Anchor — must be last in content */}
            <Box
              ref={observerRef}
              data-testid="observer-anchor"
              height="1px"
              width="100%"
            />
          </Box>
        </Box>

        {/* 3️⃣ Bottom Gradient — fixed to viewport bottom */}
        <Box
          pointerEvents="none"
          data-testid="background-gradient"
          data-intensity={intensity.toFixed(4)}
          position="absolute"
          bottom="0"
          left="0"
          right="0"
          height="44px"
          bg={`linear-gradient(
            to top,
            rgba(120,170,255, ${0.32 * intensity}) 0%,
            rgba(120,170,255, ${0.18 * intensity}) 55%,
            rgba(120,170,255, 0) 100%
          )`}
        />
      </Box>
    </Box>
  );
}

function TurnRow({ block, index }: { block: any; index: number }) {
  return (
    <Box
      display="grid"
      gridTemplateColumns={{ base: "1fr", md: "1fr 1fr" }}
      px={{ base: "6vw", md: "8vw" }}
      py="100px"
      mt={index > 0 ? "-30px" : "0px"}
      position="relative"
    >
      <Pane
        side="left"
        speaker={block.speaker}
        active="security_engineer"
        block={block}
      />
      <Pane
        side="right"
        speaker={block.speaker}
        active="application_engineer"
        block={block}
      />
    </Box>
  );
}

function Pane({
  side,
  speaker,
  active,
  block,
}: {
  side: "left" | "right";
  speaker: string;
  active: string;
  block: any;
}) {
  const isActive = speaker === active;

  return (
    <Box
      display="flex"
      alignItems="center"
      justifyContent={
        side === "left" ? "flex-start" : { base: "flex-start", md: "flex-end" }
      }
      minH={{ base: "auto", md: "320px" }}
    >
      {isActive ? (
        <MeasuredBubble id={block.id} content={block.mdx} speaker={speaker} />
      ) : (
        <Box height={block.height ? `${block.height}px` : "0px"} />
      )}
    </Box>
  );
}

function MeasuredBubble({
  id,
  content,
  speaker,
}: {
  id: string;
  content: string;
  speaker: string;
}) {
  const ref = React.useRef<HTMLDivElement | null>(null);

  React.useEffect(() => {
    if (!ref.current) return;

    const el = ref.current;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        bus.emit("TURN_RENDERED", {
          id,
          height: entry.contentRect.height,
        });
      }
    });

    observer.observe(el);
    return () => observer.disconnect();
  }, [id]);

  const isSecurity = speaker === "security_engineer";

  return (
    <MotionBox
      data-testid="turn-bubble"
      ref={ref}
      transition={{ duration: 0.4, ease: "easeOut" }}
      width="70vw"
      maxW="1100px"
      fontSize="18px"
      borderLeft={isSecurity ? "3px solid rgba(120,170,255,0.35)" : undefined}
      borderRight={!isSecurity ? "3px solid rgba(255,180,120,0.35)" : undefined}
      pl={isSecurity ? "28px" : undefined}
      pr={!isSecurity ? "24px" : undefined}
      display={!isSecurity ? "flex" : "block"}
      flexDirection="column"
      alignItems={!isSecurity ? "flex-end" : undefined}
    >
      <Text
        fontSize="13px"
        letterSpacing="0.08em"
        textTransform="uppercase"
        opacity="0.6"
        mb="16px"
      >
        {isSecurity ? "Security Engineer" : "Application Engineer"}
      </Text>

      <Box width="100%" textAlign="left">
        <MdxRenderer content={content} />
      </Box>
    </MotionBox>
  );
}
</file>

</files>
