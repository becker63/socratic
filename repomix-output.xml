This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shared/
  schemas.ts
src/
  components/
    MdxRenderer.tsx
  fixtures/
    dialogue.json
  hooks/
    useAutoScroll.ts
    useDebate.ts
    useDebateProjection.ts
    useGradientProjection.ts
    useLayoutStable.ts
    useObserverAnchor.ts
    useScrollOwnership.ts
  types/
    socratic-global.d.ts
  App.tsx
  bus.ts
  debateMachine.ts
  main.tsx
  replay.ts
  testBridge.ts
test-results/
  .last-run.json
tests/
  scroll.spec.ts
.gitignore
flake.lock
flake.nix
index.html
index.ts
package.json
playwright.config.ts
server.ts
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/types/socratic-global.d.ts">
import type { SocraticBridge } from "../testBridge";

declare global {
  interface Window {
    __socratic?: SocraticBridge;
  }
}

export {};
</file>

<file path="src/bus.ts">
import mitt from "mitt";
import type { Turn } from "../shared/schemas";

export type Pane = "security" | "application";

export type Events = {
  REPLAY_START: void;
  APPEND_TURN: Turn;
  REPLAY_COMPLETE: void;

  // NEW
  TURN_RENDERED: {
    id: string;
    height: number;
  };
};

export const bus = mitt<Events>();
</file>

<file path="test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="index.html">
<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Minimal Bun + React</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
</file>

<file path="index.ts">
console.log("Hello via Bun!");
</file>

<file path="playwright.config.ts">
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./tests",
  timeout: 30_000,
  use: {
    headless: true,
    baseURL: "http://127.0.0.1:5173",
    browserName: "chromium",
    launchOptions: {
      executablePath: process.env.PLAYWRIGHT_CHROMIUM_PATH,
    },
  },
  webServer: {
    command: "bunx vite --host 127.0.0.1 --port 5173",
    url: "http://127.0.0.1:5173",
    reuseExistingServer: !process.env.CI,
    timeout: 60_000,
  },
});
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001",
    },
  },
});
</file>

<file path="src/fixtures/dialogue.json">
{
  "topic": "Zero trust in microservices",
  "turns": [
    {
      "speaker": "security_engineer",
      "mdx": "We should adopt a strict zero-trust posture for east‑west traffic using workload identities (SPIFFE), mTLS between sidecars, and OPA for fine‑grained policy enforcement.\n\nKey points:\n\n- Authenticate by identity, not network: SPIFFE SVIDs issued by SPIRE; short‑lived X.509 (or JWT‑SVID) for revocation-free rotation.\n- Encrypt and authorize at the edge of the workload: Envoy/sidecar mTLS, Envoy RBAC + OPA as an external authorizer.\n- Deny‑by‑default RBAC and attribute‑based policies (OPA/Rego) for sensitive calls (database, secrets manager).\n- Rollout strategy: permissive mTLS -> canary (5–25%) -> all, and use chaos engineering to verify cert expiry recovery paths.\n\nConcrete failure cases to prepare for:\n\n- SPIRE control plane compromise: have offline root CA and automated rotation playbooks.\n- Certificate expiry or network partition: use permissive mode with strict audit for short windows and automatic restart/renewal agents.\n\nI expect pushback on complexity and latency; I’ll address trade‑offs if you outline those concerns."
    },
    {
      "speaker": "application_engineer",
      "mdx": "I agree with identity‑first goals, but I push back on mandatory sidecars + Envoy for every service because of operational and performance costs.\n\nProblems I see:\n\n- CPU and latency: Envoy sidecars add p99 tail latency and ~5–15% CPU overhead in polyglot fleets.\n- Integration friction: not every runtime team can embed SPIFFE SDKs; sidecars can be heavy for small services (FaaS/edge devices).\n- Centralized OPA policies become deployment coupling: a policy change can break many services and slow down releases.\n\nA pragmatic alternative I propose:\n\n- North‑south: API gateway enforces strong auth (JWT introspection, rate limiting, WAF). Use token caches and introspection caching.\n- East‑west hybrid: critical services use SPIFFE mTLS; noncritical internal calls use signed JWTs with short TTL + local verification.\n- Gradual rollout: start gateway + JWTs, then progressively onboard service mesh for high‑risk paths.\n\nI want to see concrete latency measurements and rollout knobs before committing cluster‑wide sidecars."
    },
    {
      "speaker": "security_engineer",
      "mdx": "Good points — latency and operational burden are real. Still, JWTs and gateway‑only enforcement have concrete attack windows:\n\n- Replay and revocation: long‑lived JWTs are hard to revoke; token introspection adds central dependency and latency spikes.\n- Gateway compromise: a single compromised ingress gateway could mint or forward tokens to east‑west paths if we rely on gateway trust alone.\n\nHow we mitigate while addressing your concerns:\n\n- Use SPIFFE short‑lived SVIDs (X.509 or JWT‑SVID). TTLs of 10–30 minutes eliminate long revocation windows and avoid introspection for every call.\n- Reduce sidecar overhead: leverage eBPF or kernel bypass (Envoy’s XDP/AF_XDP or gVisor bypass patterns) for hot paths; restrict full proxy to critical services.\n- Rollout concretely:\n  - Phase 1: deploy SPIRE server + agents on control plane nodes; run Envoy in permissive mode (mTLS verified but not required) for 2 weeks.\n  - Phase 2: canary 5% of services with enforced mTLS and OPA policies; monitor p99 auth latency, CPU delta, and error rate.\n  - Phase 3: expand by risk category.\n\nFailure/callback plan:\n\n- If SPIRE unavailable, agents continue serving cached SVIDs until expiry; set TTLs short but long enough to survive brief outages (e.g., 15m).\n- For wider outages, auto‑rollback to permissive with strict logging and alerts, not fail‑open permanently."
    },
    {
      "speaker": "application_engineer",
      "mdx": "Accepting JWT replay concerns and the SPIFFE short‑lived solution helps. Still, the devil is in operational details and developer velocity.\n\nOperational trade‑offs I want addressed before full adoption:\n\n- SDK vs sidecar: SDKs avoid heavy sidecars but create language‑specific maintenance across many teams. Sidecars centralize complexity but hurt resource budgets.\n- Observability/perf KPIs: we need concrete thresholds before canary expansion (acceptable p99 increase, CPU budget per pod, memory).\n- Policy ownership: OPA as a centralized policy store needs guardrails (policy review workflow, testing harnesses).\n\nProposed hybrid implementation to compromise:\n\n- Use SPIRE agents + sidecars for critical, high‑risk services (payments, auth, db proxies).\n- Use JWT‑SVID (SPIFFE supports JWT‑SVID) for lightweight validation in low‑risk services — apps validate locally with a stable public key bundle.\n- Deploy OPA as a local sidecar for low latency but keep a central OPA server for policy authorship and CI testing; use policy signing and automated promotion.\n\nAlso, we should create canary KPIs: start at 5% traffic, expand if p99 auth latency delta <2ms and CPU overhead <5%."
    },
    {
      "speaker": "security_engineer",
      "mdx": "I like the hybrid shape and it's consistent with SPIFFE capabilities. A few concrete mechanisms and operational controls I insist on:\n\n- Use JWT‑SVIDs where appropriate: SPIRE issues JWT‑SVIDs so apps can validate tokens offline using the trust bundle (no introspection). This addresses your SDK concern without sacrificing short TTLs.\n- Policy enforcement: use Envoy RBAC + OPA plugin for complex attribute logic; OPA Gatekeeper for K8s admission controls to stop misconfigurations.\n- Failover and TTL specifics:\n  - Certificate/SVID TTL: 10–30 minutes (trade‑off: shorter TTL reduces compromise window but increases issuance load).\n  - SPIRE HA: run SPIRE server as an HA set; monitor issuance latency and queue length; alert at issuance latency >500ms or queue >1000.\n- Rollback strategy: permissive mode with strict audit for a maximum window (e.g., 4 hours) and automated rollback if:\n  - p99 auth latency increases >2ms above baseline, or\n  - request error rate increases by >1% absolute, or\n  - CPU overhead >7% on canary pods.\n\nMinimal diagram of the flow:\n\n```mermaid\nflowchart LR\n  A[workload] -->|fetch SVID| B[SPIRE agent]\n  A -->|mTLS| C[sidecar Envoy]\n  C -->|policy check| D[OPA sidecar]\n  D --> E[target service]\n```\n\nI’ll own SPIRE outage playbooks and automated alerts if we agree on the KPI thresholds above."
    },
    {
      "speaker": "application_engineer",
      "mdx": "That diagram and the concrete thresholds make the plan actionable. I accept the hybrid architecture provided we lock down these operational SLAs and automation steps:\n\n- KPIs and rollout gates:\n  - Canary progression: 5% -> 25% -> 100% when p99 auth latency delta <= 2ms and CPU overhead <= 5%.\n  - If error rate increases >1% or auth failures >0.1% for 10 minutes, auto‑rollback to permissive for affected canaries.\n- Performance mitigations:\n  - Use eBPF for in‑kernel fast path where possible and an Envoy wasm filter for lightweight policy checks.\n  - Cache public bundles for JWT‑SVID validation, refresh off‑peak.\n- Responsibilities:\n  - Security owns SPIRE HA, TTL tuning, and automated rollback playbooks.\n  - Platform owns sidecar deployment patterns, eBPF integration, and a policy CI that validates Rego on test traffic.\n\nIf you commit to those duties and the canary gates, I’ll start a pilot with three critical services and measure metrics for two weeks before broader rollout."
    }
  ]
}
</file>

<file path="src/hooks/useAutoScroll.ts">
import { useLayoutEffect, useRef } from "react";

/**
 * useAutoScroll
 *
 * Responsibility:
 * ----------------
 * Perform automatic scroll-to-bottom behavior when:
 *   - New content (blocks) is appended
 *   - The state machine currently owns scrolling ("machineOwned")
 *   - Layout has fully stabilized (MDX + Mermaid rendered, heights settled)
 *
 * Design Principles:
 * ------------------
 * 1. Never scroll before layout is stable.
 * 2. Never scroll if the user owns scrolling.
 * 3. Scroll exactly once per append event.
 * 4. Suppress ownership recalculation while we are restoring scroll.
 *
 * This hook is intentionally imperative and uses refs instead of state
 * because this is coordination logic, not UI state.
 */
export function useAutoScroll(
  scrollRef: React.RefObject<HTMLDivElement | null>,

  /**
   * The number of rendered blocks.
   * When this increases, it means new content has been appended.
   */
  blocksLength: number,

  /**
   * Current scroll ownership, derived from the XState machine.
   * - "machineOwned" → auto-scroll allowed
   * - "userOwned"    → do not interfere
   */
  scrollOwner: "machineOwned" | "userOwned",

  /**
   * True only after layout has fully stabilized.
   * Provided by useLayoutStable (ResizeObserver-based settling).
   */
  layoutReady: boolean,
) {
  /**
   * Tracks the previous blocks length.
   * Used to detect content growth (append events).
   */
  const prevLengthRef = useRef(blocksLength);

  /**
   * A one-shot latch indicating:
   *   "We owe the viewport a scroll-to-bottom once layout stabilizes."
   *
   * Why needed:
   * - New content may append before layoutReady becomes true.
   * - We must remember that a scroll is required.
   * - We must perform it exactly once.
   *
   * This is not UI state — it is internal coordination memory.
   */
  const pendingScrollRef = useRef(false);

  /**
   * Indicates that we are currently performing a machine-driven
   * scroll restoration.
   *
   * This is consumed by useScrollOwnership to avoid misinterpreting
   * our own programmatic scroll as a user scroll.
   */
  const restoringRef = useRef(false);

  /**
   * useLayoutEffect is used instead of useEffect because:
   * - We want scroll mutation to occur before the browser paints.
   * - This prevents visible flicker or mid-frame repositioning.
   */
  useLayoutEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    /* ------------------------------------------------------------
       Phase 1 — Detect Content Growth
    ------------------------------------------------------------ */

    // If blocksLength changed, new content was appended.
    if (blocksLength !== prevLengthRef.current) {
      prevLengthRef.current = blocksLength;

      // Only schedule auto-scroll if machine owns scrolling.
      // If user owns scroll, we intentionally do nothing.
      if (scrollOwner === "machineOwned") {
        pendingScrollRef.current = true;
      }
    }

    /* ------------------------------------------------------------
       Phase 2 — Execute Deferred Scroll (Once Layout Is Stable)
    ------------------------------------------------------------ */

    // Only scroll when:
    // - layout has settled (heights finalized)
    // - we previously recorded intent to scroll
    if (layoutReady && pendingScrollRef.current) {
      // Mark that this scroll is programmatic.
      restoringRef.current = true;

      // Jump to bottom.
      // We use scrollHeight to ensure exact bottom alignment.
      el.scrollTop = el.scrollHeight;

      // Manually dispatch scroll so ownership logic recalculates.
      // Without this, useScrollOwnership may not re-evaluate.
      el.dispatchEvent(new Event("scroll"));

      // Reset flags.
      restoringRef.current = false;
      pendingScrollRef.current = false;
    }
  }, [blocksLength, layoutReady, scrollOwner]);

  /**
   * We return restoringRef so useScrollOwnership can suppress
   * machine-driven scroll events.
   *
   * This is an intentional cross-hook coordination channel.
   */
  return restoringRef;
}
</file>

<file path="src/hooks/useGradientProjection.ts">
import { useEffect, useState } from "react";
import type { ObserverMetrics } from "./useObserverAnchor";

/**
 * useGradientProjection
 *
 * Responsibility:
 * Convert geometry telemetry (anchor position)
 * into a normalized visual intensity signal.
 *
 * This hook does not read DOM.
 * It purely transforms metrics → presentation value.
 */
export function useGradientProjection(
  observerMetrics: ObserverMetrics | null,
  layoutReady: boolean,
  maxDistance: number = 400,
) {
  // Final eased intensity used by UI
  const [intensity, setIntensity] = useState(0);

  // Raw 0–1 normalized distance before easing
  const [normalizedPosition, setNormalizedPosition] = useState(0);

  useEffect(() => {
    // Do nothing until layout is stable and we have metrics
    if (!layoutReady || !observerMetrics) return;

    const { midYInViewport, viewportHeight } = observerMetrics;

    /**
     * Distance between anchor midpoint and viewport bottom.
     * When anchor approaches bottom, gradient intensity increases.
     */
    const distanceFromViewportBottom = viewportHeight - midYInViewport;

    /**
     * Normalize distance into 0–1 range.
     * Clamped to avoid overflow.
     */
    const normalized = Math.max(
      0,
      Math.min(distanceFromViewportBottom / maxDistance, 1),
    );

    /**
     * Apply cubic ease-out for smoother visual falloff.
     * Keeps interaction feeling soft instead of linear.
     */
    const eased = 1 - Math.pow(1 - normalized, 3);

    setNormalizedPosition(normalized);
    setIntensity(eased);
  }, [observerMetrics, layoutReady, maxDistance]);

  return { intensity, normalizedPosition };
}
</file>

<file path="src/hooks/useLayoutStable.ts">
import { useEffect, useState } from "react";

/**
 * useLayoutStable
 *
 * Responsibility:
 * Detect when scroll content has stopped resizing for a short window.
 *
 * This is necessary because:
 * - MDX rendering
 * - Mermaid diagrams
 * - dynamic height measurement
 *
 * all cause asynchronous layout changes.
 *
 * We mark layout as "ready" only after no ResizeObserver events
 * fire for `settleMs` milliseconds.
 */
export function useLayoutStable(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  blocks: unknown[],
  settleMs: number = 150,
) {
  // True once layout has fully settled
  const [ready, setReady] = useState(false);

  // Incremented whenever layout re-stabilizes
  // Useful if consumers want to react to new stable cycles
  const [version, setVersion] = useState(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    // We observe the first child (content wrapper)
    const content = el.firstElementChild as HTMLElement | null;
    if (!content) return;

    // Whenever blocks change, layout is considered unstable again
    setReady(false);

    let timeout: number | null = null;

    const observer = new ResizeObserver(() => {
      // Reset debounce window on every resize
      if (timeout) window.clearTimeout(timeout);

      timeout = window.setTimeout(() => {
        // Layout has been stable for settleMs
        setReady(true);
        setVersion((v) => v + 1);
      }, settleMs);
    });

    observer.observe(content);

    return () => {
      observer.disconnect();
      if (timeout) window.clearTimeout(timeout);
    };
  }, [scrollRef, blocks.length, settleMs]);

  return { ready, version };
}
</file>

<file path="src/hooks/useObserverAnchor.ts">
import { useEffect, useRef, useState } from "react";

/**
 * ObserverMetrics
 *
 * These are geometry values derived from the DOM.
 * They are intentionally minimal — just enough to drive projection logic
 * (e.g., gradient intensity) without leaking full layout complexity.
 */
export type ObserverMetrics = {
  /**
   * The vertical midpoint of the anchor element,
   * expressed in viewport coordinates (relative to the window).
   *
   * Used to determine how close the anchor is to the bottom
   * of the visible scroll region.
   */
  midYInViewport: number;

  /**
   * The bottom of the anchor element,
   * expressed in content coordinates (relative to the scroll container).
   *
   * This is useful if we ever want to reason about
   * content-relative positioning instead of viewport-relative.
   */
  bottomInContent: number;

  /**
   * The visible height of the scroll viewport.
   * Used to normalize distance calculations.
   */
  viewportHeight: number;
};

/**
 * useObserverAnchor
 *
 * Responsibility:
 * ----------------
 * Attach a physical "anchor" element to the bottom of the scroll content
 * and continuously measure its spatial relationship to the viewport.
 *
 * This hook does NOT make decisions.
 * It only measures geometry and exposes it.
 *
 * Design Principles:
 * ------------------
 * 1. Only activate after layout has stabilized.
 * 2. Avoid leaking DOM complexity to consumers.
 * 3. Keep geometry calculations centralized and minimal.
 * 4. React to both scroll and window resize.
 */
export function useObserverAnchor(
  /**
   * Ref to the scrollable viewport container.
   */
  scrollRef: React.RefObject<HTMLDivElement | null>,

  /**
   * True only after layout (MDX, Mermaid, content height)
   * has fully stabilized.
   *
   * We do not measure geometry before layout is ready,
   * because early reads would be incorrect and noisy.
   */
  layoutReady: boolean,
) {
  /**
   * Ref to the invisible anchor element.
   *
   * This element is placed at the bottom of the content
   * and acts as a physical probe.
   */
  const observerRef = useRef<HTMLDivElement | null>(null);

  /**
   * The latest computed geometry metrics.
   * Null until first measurement occurs.
   */
  const [metrics, setMetrics] = useState<ObserverMetrics | null>(null);

  useEffect(() => {
    /**
     * Do nothing until layout is stable.
     * Prevents reading incomplete DOM geometry.
     */
    if (!layoutReady) return;

    const scroller = scrollRef.current;
    const observer = observerRef.current;

    if (!scroller || !observer) return;

    /**
     * update()
     *
     * Reads live DOM geometry and projects it into
     * a minimal, normalized metric shape.
     *
     * This is intentionally the ONLY place that
     * DOM layout reads occur for this concern.
     */
    const update = () => {
      /**
       * getBoundingClientRect gives viewport-relative coordinates.
       */
      const scrollerRect = scroller.getBoundingClientRect();
      const observerRect = observer.getBoundingClientRect();

      /**
       * Midpoint of the anchor in viewport space.
       *
       * We use midpoint instead of top/bottom directly
       * to create smoother projection behavior.
       */
      const midYInViewport = observerRect.top + observerRect.height / 2;

      /**
       * Bottom of anchor in content space.
       *
       * offsetTop is relative to offsetParent,
       * which here corresponds to the scroll content wrapper.
       */
      const bottomInContent = observer.offsetTop + observer.offsetHeight;

      /**
       * Visible height of scroll viewport.
       */
      const viewportHeight = scroller.clientHeight;

      setMetrics({
        midYInViewport,
        bottomInContent,
        viewportHeight,
      });
    };

    /**
     * Initial measurement.
     */
    update();

    /**
     * Listen to scroll events.
     * Passive because we do not preventDefault.
     */
    scroller.addEventListener("scroll", update, { passive: true });

    /**
     * Also listen to window resize,
     * since viewport height changes affect projections.
     */
    window.addEventListener("resize", update);

    return () => {
      scroller.removeEventListener("scroll", update);
      window.removeEventListener("resize", update);
    };
  }, [layoutReady, scrollRef]);

  /**
   * Return:
   * - observerRef → attach to bottom anchor element
   * - observerMetrics → continuously updated geometry signal
   *
   * Consumers (like gradient projection) should treat
   * this as read-only physical telemetry.
   */
  return { observerRef, observerMetrics: metrics };
}
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { ChakraProvider, defaultSystem } from "@chakra-ui/react";
import { App } from "./App";
import { installTestBridge } from "./testBridge";

let inspector: ReturnType<
  typeof import("@statelyai/inspect").createBrowserInspector
> | null = null;

if (import.meta.env.DEV) {
  const { createBrowserInspector } = await import("@statelyai/inspect");

  inspector = createBrowserInspector();
}

installTestBridge();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ChakraProvider value={defaultSystem}>
      <App inspector={inspector} />
    </ChakraProvider>
  </React.StrictMode>,
);
</file>

<file path="src/replay.ts">
import type { Dialogue } from "../shared/schemas";
import { bus } from "./bus";

const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function computeDelay(mdx: string) {
  const words = mdx.split(/\s+/).length;

  // Base delay + reading time
  const base = 800; // minimum pause
  const perWord = 25; // reading pacing

  return base + words * perWord;
}

export async function replayDialogue(dialogue: Dialogue) {
  bus.emit("REPLAY_START");

  for (const turn of dialogue.turns) {
    console.log("[bus] APPEND_TURN");
    bus.emit("APPEND_TURN", turn);

    const delay = computeDelay(turn.mdx);

    await sleep(delay);
  }

  bus.emit("REPLAY_COMPLETE");
}
</file>

<file path="src/testBridge.ts">
// src/testBridge.ts
import { bus } from "./bus";

/* ------------------------------------------------------------
   Machine Log Shape
------------------------------------------------------------ */

export type MachineLogEvent = {
  t: number;
  phase: "event" | "transition";
  event?: string;
  value: unknown;
  context: unknown;
};

/* ------------------------------------------------------------
   Bridge Interface
------------------------------------------------------------ */

export interface SocraticBridge {
  emit: (type: string, payload?: unknown) => void;
  machineEvents: MachineLogEvent[];
  onMachineEvent: (payload: MachineLogEvent) => void;
  clearMachineEvents: () => void;
}

/* ------------------------------------------------------------
   Global Window Augmentation
------------------------------------------------------------ */

declare global {
  interface Window {
    __socratic?: SocraticBridge;
  }
}

/* ------------------------------------------------------------
   Install Bridge
------------------------------------------------------------ */

export function installTestBridge() {
  // Only install in dev or test mode
  if (!import.meta.env.DEV && import.meta.env.MODE !== "test") return;

  const bridge: SocraticBridge = {
    emit: (type, payload) => {
      bus.emit(type as any, payload);
    },

    machineEvents: [],

    onMachineEvent(payload) {
      bridge.machineEvents.push(payload);
    },

    clearMachineEvents() {
      bridge.machineEvents.length = 0;
    },
  };

  window.__socratic = bridge;
}
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1767039857,
        "narHash": "sha256-vNpUSpF5Nuw8xvDLj2KCwwksIbjua2LZCqhV1LNRDns=",
        "owner": "NixOS",
        "repo": "flake-compat",
        "rev": "5edf11c44bc78a0d334f6334cdaf7d60d732daab",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "git-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1772024342,
        "narHash": "sha256-+eXlIc4/7dE6EcPs9a2DaSY3fTA9AE526hGqkNID3Wg=",
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "6e34e97ed9788b17796ee43ccdbaf871a5c2b476",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "git-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1770073757,
        "narHash": "sha256-Vy+G+F+3E/Tl+GMNgiHl9Pah2DgShmIUBJXmbiQPHbI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "47472570b1e607482890801aeaf29bfb749884f6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1771848320,
        "narHash": "sha256-0MAd+0mun3K/Ns8JATeHT1sX28faLII5hVLq0L3BdZU=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2fc6539b481e1d2569f25f8799236694180c0993",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "git-hooks": "git-hooks",
        "nixpkgs": "nixpkgs_2"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "moduleDetection": "force",
    "verbatimModuleSyntax": true,
    "allowImportingTsExtensions": true,

    "noEmit": true,

    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "tests/**/*.ts"]
}
</file>

<file path="shared/schemas.ts">
// shared/schemas.ts
import { z } from "zod";

/**
 * Prompt Input
 */
export const PromptRequestSchema = z.object({
  prompt: z.string().min(1),
});

/**
 * Speakers
 */
export const SpeakerSchema = z.enum([
  "security_engineer",
  "application_engineer",
]);

export type Speaker = z.infer<typeof SpeakerSchema>;

/**
 * A single conversational turn.
 * mdx is markdown/MDX-ish content (we'll render as markdown).
 * Mermaid diagrams are expressed as ```mermaid code fences inside mdx.
 */
export const TurnSchema = z.object({
  speaker: SpeakerSchema,
  mdx: z.string().min(1),
});

export type Turn = z.infer<typeof TurnSchema>;

/**
 * Dialogue root
 */
export const DialogueSchema = z.object({
  topic: z.string().min(1),
  turns: z.array(TurnSchema).min(6).max(12),
});

export type Dialogue = z.infer<typeof DialogueSchema>;
</file>

<file path="src/components/MdxRenderer.tsx">
import React from "react";
import { Box } from "@chakra-ui/react";
import { MarkdownHooks } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeMermaid from "rehype-mermaid";

export function MdxRenderer({ content }: { content: string }) {
  return (
    <Box
      css={{
        "& p": { marginBottom: "1rem", lineHeight: 1.8 },
        "& ul": { paddingLeft: "1.4rem", marginBottom: "1rem" },
        "& li": { marginBottom: "0.4rem" },
        "& pre": {
          background: "rgba(255,255,255,0.04)",
          padding: "1rem",
          borderRadius: "12px",
          border: "1px solid rgba(255,255,255,0.06)",
          overflowX: "auto",
          fontSize: "0.9rem",
        },
        "& code": {
          background: "rgba(255,255,255,0.08)",
          padding: "0.2rem 0.4rem",
          borderRadius: "6px",
        },
        "& svg": {
          background: "rgba(255,255,255,0.03)",
          borderRadius: "12px",
          padding: "0.5rem",
        },
      }}
    >
      <MarkdownHooks
        key={content}
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[[rehypeMermaid, { strategy: "inline-svg" }]]}
      >
        {content}
      </MarkdownHooks>
    </Box>
  );
}
</file>

<file path="src/hooks/useDebate.ts">
import { useState, useEffect, useMemo } from "react";
import { useMachine } from "@xstate/react";
import {
  PromptRequestSchema,
  DialogueSchema,
  type Dialogue,
} from "../../shared/schemas";
import fixtureData from "../fixtures/dialogue.json";
import { debateMachine } from "../debateMachine";

const USE_STATIC_FIXTURE = true;

export function useDebate(inspect?: any) {
  const [prompt, setPrompt] = useState("Zero trust in microservices");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // actor is the authoritative runtime instance
  const [state, originalSend, actor] = useMachine(debateMachine, {
    inspect,
  });

  /* ------------------------------------------------------------
     Pre-Transition Logging (Event Boundary)
  ------------------------------------------------------------ */

  // Wrap send so we log every event entering the machine
  const send = useMemo(() => {
    return (event: Parameters<typeof originalSend>[0]) => {
      const before = actor.getSnapshot();

      const payload = {
        t: performance.now(),
        phase: "event",
        event: event.type,
        value: before.value,
        context: before.context,
      };

      console.log("[machine event]", payload);

      if (typeof window !== "undefined") {
        const w = window as any;
        w.__socratic?.onMachineEvent?.(payload);
      }

      originalSend(event);
    };
  }, [originalSend, actor]);

  /* ------------------------------------------------------------
     Post-Transition Logging (State Boundary)
  ------------------------------------------------------------ */

  useEffect(() => {
    if (!actor) return;

    const sub = actor.subscribe((snapshot) => {
      const payload = {
        t: performance.now(),
        phase: "transition",
        value: snapshot.value,
        context: snapshot.context,
      };

      console.log("[machine transition]", payload);

      if (typeof window !== "undefined") {
        const w = window as any;
        w.__socratic?.onMachineEvent?.(payload);
      }
    });

    return () => sub.unsubscribe();
  }, [actor]);

  /* ------------------------------------------------------------
     Domain Commands
  ------------------------------------------------------------ */

  async function generate() {
    setLoading(true);
    setError(null);

    try {
      let parsed: Dialogue;

      if (USE_STATIC_FIXTURE) {
        parsed = DialogueSchema.parse(fixtureData);
      } else {
        const body = PromptRequestSchema.parse({ prompt });

        const resp = await fetch("/api/dialogue", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(body),
        });

        if (!resp.ok) throw new Error(await resp.text());

        parsed = DialogueSchema.parse(await resp.json());
      }

      send({ type: "GENERATE", dialogue: parsed });
    } catch (e) {
      setError(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  }

  function replay() {
    send({ type: "REPLAY" });
  }

  return {
    prompt,
    setPrompt,
    loading,
    error,
    send, // wrapped send (instrumented)
    state,
    generate,
    replay,
  };
}
</file>

<file path="src/hooks/useDebateProjection.ts">
import { useEffect, useState } from "react";
import type { Turn } from "../../shared/schemas";
import { bus } from "../bus";

/**
 * LayoutBlock
 *
 * UI-projected representation of a Turn.
 * Adds:
 * - stable unique id
 * - measured height (for mirrored panes)
 */
export type LayoutBlock = Turn & {
  id: string;
  height?: number;
};

/**
 * useDebateProjection
 *
 * Responsibility:
 * Project domain events (via bus) into renderable UI blocks.
 *
 * This is an event → view-model adapter.
 * It keeps UI concerns (ids, measured height)
 * separate from the state machine.
 */
export function useDebateProjection() {
  const [blocks, setBlocks] = useState<LayoutBlock[]>([]);

  useEffect(() => {
    // Clear projection on replay start
    function onStart() {
      setBlocks([]);
    }

    // Append new turn to projection
    function onAppend(turn: Turn) {
      setBlocks((prev) => [
        ...prev,
        {
          ...turn,
          id: crypto.randomUUID(), // stable render key
        },
      ]);
    }

    // Update measured height once bubble renders
    function onRendered({ id, height }: { id: string; height: number }) {
      setBlocks((prev) =>
        prev.map((b) => (b.id === id ? { ...b, height } : b)),
      );
    }

    bus.on("REPLAY_START", onStart);
    bus.on("APPEND_TURN", onAppend);
    bus.on("TURN_RENDERED", onRendered);

    return () => {
      bus.off("REPLAY_START", onStart);
      bus.off("APPEND_TURN", onAppend);
      bus.off("TURN_RENDERED", onRendered);
    };
  }, []);

  return blocks;
}
</file>

<file path="src/hooks/useScrollOwnership.ts">
import { useEffect, useRef } from "react";
import type { AnyActorRef } from "xstate";

/**
 * useScrollOwnership
 *
 * Responsibility:
 * ----------------
 * Detect whether the user or the machine currently "owns" scroll.
 *
 * This hook translates raw DOM scroll movement into semantic events
 * for the XState machine:
 *
 *   - USER_SCROLLED_UP  → transition to userOwned
 *   - USER_AT_BOTTOM    → transition to machineOwned
 *
 * Design Goals:
 * -------------
 * 1. Only emit ownership transitions when they truly change.
 * 2. Never treat machine-driven scroll restoration as user input.
 * 3. Be resilient to small pixel drift.
 * 4. Avoid event spam.
 *
 * This is the arbitration layer between:
 *   - Physical scroll movement
 *   - Semantic ownership state
 */
export function useScrollOwnership(
  /**
   * XState send function.
   * We emit semantic ownership events into the machine.
   */
  send: AnyActorRef["send"],

  /**
   * Ref to the scrollable viewport.
   */
  scrollRef: React.RefObject<HTMLDivElement | null>,

  /**
   * Shared ref from useAutoScroll.
   * When true, we are currently restoring scroll programmatically.
   * During restoration, ownership logic must be suppressed.
   */
  restoringRef: React.MutableRefObject<boolean>,
) {
  /**
   * Tracks whether we previously considered ourselves at bottom.
   * Used to prevent emitting duplicate machine events.
   */
  const lastAtBottomRef = useRef<boolean | null>(null);

  /**
   * Tracks the previous scrollTop value.
   * Used to determine scroll direction (up vs down).
   */
  const lastScrollTopRef = useRef<number>(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    /**
     * checkOwnership
     *
     * Called on every scroll event.
     * Converts raw scroll metrics into semantic ownership signals.
     */
    const checkOwnership = () => {
      const currentScrollTop = el.scrollTop;

      /**
       * Are we effectively at bottom?
       *
       * We allow a 5px tolerance to prevent flicker due to
       * rounding errors or fractional layout differences.
       */
      const atBottom =
        currentScrollTop + el.clientHeight >= el.scrollHeight - 5;

      /**
       * Determine scroll direction.
       * This helps distinguish intentional upward scroll
       * from incidental position drift.
       */
      const scrollingUp = currentScrollTop < lastScrollTopRef.current;
      const scrollingDown = currentScrollTop > lastScrollTopRef.current;

      console.log("[ownership check]", {
        scrollTop: currentScrollTop,
        clientHeight: el.clientHeight,
        scrollHeight: el.scrollHeight,
        atBottom,
        restoring: restoringRef.current,
        lastAtBottom: lastAtBottomRef.current,
        scrollingUp,
        scrollingDown,
      });

      /**
       * Update scroll tracker immediately.
       * This ensures future direction comparisons are accurate.
       */
      lastScrollTopRef.current = currentScrollTop;

      /**
       * Suppress ownership logic during machine-driven restoration.
       *
       * Without this, a programmatic scroll-to-bottom
       * would be interpreted as user scroll,
       * causing oscillation between states.
       */
      if (restoringRef.current) return;

      /* ------------------------------------------------------------
         Case 1: User scrolls upward and is no longer at bottom
      ------------------------------------------------------------ */

      if (!atBottom && scrollingUp) {
        /**
         * Only emit transition if ownership is actually changing.
         * Prevents duplicate USER_SCROLLED_UP events.
         */
        if (lastAtBottomRef.current !== false) {
          lastAtBottomRef.current = false;

          // Semantic transition: machine → user ownership
          send({ type: "USER_SCROLLED_UP" });
        }
        return;
      }

      /* ------------------------------------------------------------
         Case 2: Scroll position reaches bottom
      ------------------------------------------------------------ */

      if (atBottom) {
        /**
         * Only emit transition if ownership is changing.
         */
        if (lastAtBottomRef.current !== true) {
          lastAtBottomRef.current = true;

          // Semantic transition: user → machine ownership
          send({ type: "USER_AT_BOTTOM" });
        }
      }

      /**
       * Note:
       * We intentionally do nothing for:
       *   - scrollingDown but not yet at bottom
       *   - small drift while still at bottom
       *
       * Ownership only changes on meaningful boundary crossings.
       */
    };

    /**
     * Passive listener because we do not preventDefault
     * and we want scroll performance preserved.
     */
    el.addEventListener("scroll", checkOwnership, { passive: true });

    /* ------------------------------------------------------------
       Initialize baseline state
    ------------------------------------------------------------ */

    lastScrollTopRef.current = el.scrollTop;
    lastAtBottomRef.current =
      el.scrollTop + el.clientHeight >= el.scrollHeight - 5;

    // Run once to align machine with initial position.
    checkOwnership();

    return () => {
      el.removeEventListener("scroll", checkOwnership);
    };
  }, [send, scrollRef, restoringRef]);
}
</file>

<file path="src/debateMachine.ts">
// src/machines/debateMachine.ts
import { setup, assign, fromPromise } from "xstate";
import type { Dialogue } from "../shared/schemas";
import { replayDialogue } from "./replay";

/* ------------------------------------------------------------
   Machine
------------------------------------------------------------ */

export const debateMachine = setup({
  types: {
    context: {} as {
      dialogue: Dialogue | null;
      error: string | null;
    },
    events: {} as
      | { type: "GENERATE"; dialogue: Dialogue }
      | { type: "REPLAY" }
      | { type: "USER_SCROLLED_UP" }
      | { type: "USER_AT_BOTTOM" }
      | { type: "FAIL"; error: string },
  },

  actors: {
    replayActor: fromPromise(
      async ({ input }: { input: { dialogue: Dialogue } }) => {
        await replayDialogue(input.dialogue);
      },
    ),
  },
}).createMachine({
  id: "debate",
  type: "parallel",

  context: {
    dialogue: null,
    error: null,
  },

  states: {
    /* ------------------------------------------------------------
       Lifecycle Control Plane
    ------------------------------------------------------------ */

    lifecycle: {
      initial: "idle",

      states: {
        idle: {
          on: {
            GENERATE: {
              target: "ready",
              actions: assign({
                dialogue: ({ event }) => event.dialogue,
                error: () => null,
              }),
            },
          },
        },

        ready: {
          on: {
            REPLAY: {
              target: "replaying",
            },
          },
        },

        replaying: {
          invoke: {
            src: "replayActor",
            input: ({ context }) => {
              if (!context.dialogue) {
                throw new Error("No dialogue available");
              }
              return { dialogue: context.dialogue };
            },
            onDone: {
              target: "complete",
            },
            onError: {
              target: "error",
              actions: assign({
                error: ({ event }) => String(event.error),
              }),
            },
          },
        },

        complete: {
          on: {
            REPLAY: {
              target: "replaying",
            },
          },
        },

        error: {
          on: {
            GENERATE: {
              target: "ready",
              actions: assign({
                dialogue: ({ event }) => event.dialogue,
                error: () => null,
              }),
            },
          },
        },
      },
    },

    /* ------------------------------------------------------------
       Scroll Ownership Control Plane
    ------------------------------------------------------------ */

    scroll: {
      initial: "machineOwned",

      states: {
        machineOwned: {
          on: {
            USER_SCROLLED_UP: {
              target: "userOwned",
            },
          },
        },

        userOwned: {
          on: {
            USER_AT_BOTTOM: {
              target: "machineOwned",
            },
          },
        },
      },
    },
  },
});
</file>

<file path="tests/scroll.spec.ts">
import { test, expect } from "@playwright/test";
import type { Page } from "@playwright/test";
import type { Turn } from "../shared/schemas";

/* ============================================================
   Scroll Ownership E2E Tests

   These tests validate two layers simultaneously:

   1) Control plane (XState)
      - machineOwned vs userOwned
      - USER_SCROLLED_UP / USER_AT_BOTTOM transitions

   2) Physical scroll geometry
      - Whether the viewport is actually at bottom
      - Whether auto-scroll truly occurred

   We are NOT just checking state flags.
   We are validating that physical scroll behavior matches
   machine authority semantics.
============================================================ */

/* ------------------------------------------------------------
   Helpers
------------------------------------------------------------ */

/**
 * Creates a tall turn so that scrolling is meaningful.
 * Each turn contains enough repeated text to produce
 * vertical overflow in the scroll container.
 */
function turn(i: number): Turn {
  return {
    speaker: i % 2 === 0 ? "security_engineer" : "application_engineer",
    mdx: `Turn ${i}\n\n` + "word ".repeat(200),
  };
}

/**
 * Waits until:
 * 1) The test bridge is installed (window.__socratic exists)
 * 2) The scroll viewport is mounted in the DOM
 *
 * This prevents DOM race conditions where React has not yet mounted.
 */
async function waitForAppReady(page: Page) {
  await page.waitForFunction(() => !!window.__socratic);
  await page.waitForSelector("[data-testid='scroll-viewport']");
}

/**
 * Emits APPEND_TURN events through the bridge.
 * This simulates replay-driven content growth.
 */
async function appendTurns(page: Page, count: number) {
  for (let i = 0; i < count; i++) {
    await page.evaluate((payload: Turn) => {
      window.__socratic?.emit("APPEND_TURN", payload);
    }, turn(i));
  }
}

/**
 * Simulates a user scroll by mutating scrollTop and
 * manually dispatching a scroll event.
 *
 * This ensures ownership logic is triggered.
 */
async function manualScroll(page: Page, delta: number) {
  await page.evaluate((amount) => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    el.scrollTop += amount;
    el.dispatchEvent(new Event("scroll"));
  }, delta);
}

/**
 * Force scroll to bottom.
 * Used to simulate a user returning control to the machine.
 */
async function scrollToBottom(page: Page) {
  await page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    el.scrollTop = el.scrollHeight;
    el.dispatchEvent(new Event("scroll"));
  });
}

/**
 * Reads scroll ownership from DOM attribute.
 * This reflects XState's parallel "scroll" region.
 */
async function getOwner(page: Page) {
  return page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner");
}

/* ------------------------------------------------------------
   Console passthrough (useful during debugging)
------------------------------------------------------------ */

test.beforeEach(async ({ page }) => {
  page.on("console", (msg) => {
    console.log(`[browser:${msg.type()}]`, msg.text());
  });
});

/* ------------------------------------------------------------
   Fresh State
------------------------------------------------------------ */

/**
 * On first load:
 *
 * - No content overflow yet.
 * - Scroll position is naturally at top.
 * - But since top === bottom (no overflow),
 *   machine should own scroll.
 */
test("fresh load starts machineOwned", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  const owner = await getOwner(page);
  expect(owner).toBe("machineOwned");
});

/* ------------------------------------------------------------
   Auto-scroll behavior
------------------------------------------------------------ */

/**
 * This test verifies the core invariant:
 *
 * When machineOwned and content is appended,
 * the viewport must automatically scroll to bottom.
 *
 * We validate BOTH:
 *   1) Ownership state
 *   2) Physical geometry
 *
 * ------------------------------------------------------------
 * Geometry Explanation:
 *
 *   scrollTop      → distance from top
 *   clientHeight   → viewport height
 *   scrollHeight   → total content height
 *
 * If the viewport is at bottom:
 *
 *   scrollTop + clientHeight ≈ scrollHeight
 *
 * ASCII diagram:
 *
 *   |----------------------|   <- scrollHeight (content bottom)
 *   |                      |
 *   |                      |
 *   |   visible viewport   |   <- clientHeight
 *   |                      |
 *   |----------------------|
 *   ^
 *   scrollTop
 *
 * Due to subpixel rounding and layout jitter,
 * we allow a tolerance of 5px.
 */
test("machineOwned auto-scrolls on append", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  // Grow content beyond viewport height
  await appendTurns(page, 8);

  // Machine should retain ownership
  await expect.poll(() => getOwner(page)).toBe("machineOwned");

  // Verify physical scroll invariant
  await expect
    .poll(async () =>
      page.evaluate(() => {
        const el = document.querySelector(
          "[data-testid='scroll-viewport']",
        ) as HTMLElement;

        const bottomEdge = el.scrollTop + el.clientHeight;
        const contentBottom = el.scrollHeight;

        // Allow 5px tolerance for layout rounding
        return bottomEdge >= contentBottom - 5;
      }),
    )
    .toBeTruthy();
});

/* ------------------------------------------------------------
   Manual Scroll Behavior
------------------------------------------------------------ */

/**
 * If the user scrolls upward:
 *
 * - We are no longer at bottom
 * - Ownership must transfer to userOwned
 *
 * This ensures:
 *   machine does not fight the user
 */
test("manual scroll up transitions to userOwned", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);
  await scrollToBottom(page);

  // Simulate user scrolling upward
  await manualScroll(page, -600);

  await expect.poll(() => getOwner(page)).toBe("userOwned");
});

/* ------------------------------------------------------------
   Returning to bottom
------------------------------------------------------------ */

/**
 * If the user scrolls back to bottom:
 *
 * - USER_AT_BOTTOM event should fire
 * - Ownership must return to machineOwned
 *
 * This restores auto-scroll authority.
 */
test("scrolling back to bottom transitions to machineOwned", async ({
  page,
}) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);
  await scrollToBottom(page);
  await manualScroll(page, -600);

  await expect.poll(() => getOwner(page)).toBe("userOwned");

  // Simulate user returning to bottom
  await scrollToBottom(page);

  await expect.poll(() => getOwner(page)).toBe("machineOwned");
});
</file>

<file path="flake.nix">
{
  description = "Bun + Vite + Playwright + Pre-commit multi-platform dev shell";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    git-hooks.url = "github:cachix/git-hooks.nix";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
      git-hooks,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };

        preCommit = git-hooks.lib.${system}.run {
          src = ./.;
          hooks = {
            # Secret scanning
            trufflehog.enable = true;
            ripsecrets.enable = true;

            # Hygiene
            nixfmt.enable = true;
            end-of-file-fixer.enable = true;
            trim-trailing-whitespace.enable = true;
          };
        };
      in
      {
        checks.pre-commit-check = preCommit;

        devShells.default = pkgs.mkShell {
          packages = [
            pkgs.bun
            pkgs.chromium
          ]
          ++ preCommit.enabledPackages;

          shellHook = ''
            ${preCommit.shellHook}

            export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
            export PLAYWRIGHT_CHROMIUM_PATH=${pkgs.chromium}/bin/chromium
            export PLAYWRIGHT_BROWSERS_PATH=0
          '';
        };
      }
    );
}
</file>

<file path="server.ts">
import { OpenAI } from "openai";
import { zodTextFormat } from "openai/helpers/zod";
import { PromptRequestSchema, DialogueSchema } from "./shared/schemas";
import { mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const SYSTEM = `
You generate a structured architectural debate between two engineer archetypes.

Return JSON that matches the provided schema exactly.

STRUCTURE:
- topic: string
- turns: array of objects
    - speaker: "security_engineer" | "application_engineer"
    - mdx: string (valid markdown / MDX content)

CONVERSATION RULES:
- The first turn must be from "security_engineer".
- Speakers must strictly alternate.
- Each speaker must contribute 3–5 turns.
- Total turns: 6–10.
- The debate must include real disagreement and trade-offs.
- Avoid generic statements.

CONTENT RULES:
- The "mdx" field must contain valid markdown.
- Allowed markdown constructs:
    - paragraphs
    - bullet lists
    - headings
    - fenced code blocks
    - mermaid fenced diagrams
- Do not include markdown fences outside the mdx string.
- Do not include commentary outside the JSON response.
- Do not include extra keys.

MERMAID RULES:
- If including a diagram, use a fenced code block with language "mermaid".
- Always begin diagrams with: flowchart LR
- Keep diagrams minimal.
- Do not use:
    - click directives
    - classDef
    - note over
    - sequenceDiagram
- Ensure valid Mermaid syntax.

STYLE:
- Technical but concise.
- Cite concrete mechanisms (e.g., SPIFFE, OPA, gateways, rollout modes, failure cases).
- Each turn should respond directly to the previous one.
`.trim();

function json(data: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(data), {
    headers: { "content-type": "application/json" },
    ...init,
  });
}

function writeFixture(dialogue: unknown) {
  const path = "./src/fixtures/dialogue.json";
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, JSON.stringify(dialogue, null, 2), "utf-8");
}

async function handleDialogue(req: Request) {
  const body = PromptRequestSchema.parse(await req.json());

  const start = performance.now();

  const response = await client.responses.parse({
    model: "gpt-5-mini",
    input: [
      { role: "system", content: SYSTEM },
      { role: "user", content: `Topic: ${body.prompt}` },
    ],
    text: {
      format: zodTextFormat(DialogueSchema, "dialogue"),
    },
  });

  const duration = performance.now() - start;

  const parsed = DialogueSchema.parse(response.output_parsed);

  // Minimal but useful logging
  console.log(
    `[openai] model=${response.model} ` +
      `latency=${duration.toFixed(0)}ms ` +
      `tokens=${response.usage?.total_tokens ?? "?"}`,
  );

  writeFixture(parsed);

  return json(parsed);
}

Bun.serve({
  port: 3001,
  async fetch(req) {
    const url = new URL(req.url);

    if (url.pathname === "/api/dialogue") {
      if (req.method !== "POST") {
        return new Response("Method Not Allowed", { status: 405 });
      }

      try {
        return await handleDialogue(req);
      } catch (e) {
        return json(
          { error: e instanceof Error ? e.message : String(e) },
          { status: 400 },
        );
      }
    }

    return new Response("Not Found", { status: 404 });
  },
});
</file>

<file path="package.json">
{
  "name": "socratic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev:server": "bun --watch server.ts",
    "dev:client": "vite",
    "dev": "concurrently -k -n server,client -c blue,green \"bun run dev:server\" \"bun run dev:client\"",
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:trace": "playwright test --trace on",
    "test:debug": "playwright test --debug"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@statelyai/inspect": "^0.4.0",
    "@types/bun": "latest",
    "@types/react": "^19.2.14",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.4",
    "concurrently": "^9.2.1",
    "vite": "^7.3.1"
  },
  "peerDependencies": {
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@chakra-ui/react": "^3.33.0",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@xstate/react": "^6.0.0",
    "framer-motion": "^12.34.3",
    "mermaid": "^11.12.3",
    "mitt": "^3.0.1",
    "openai": "^6.24.0",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "react-markdown": "^10.1.0",
    "rehype-mermaid": "^3.0.0",
    "rehype-stringify": "^10.0.1",
    "remark-gfm": "^4.0.1",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "unified": "^11.0.5",
    "xstate": "^5.28.0",
    "zod": "^4.3.6"
  }
}
</file>

<file path="src/App.tsx">
// src/App.tsx
import React from "react";
import { Box, Button, Input, Text } from "@chakra-ui/react";
import { motion } from "framer-motion";
import { useDebate } from "./hooks/useDebate";
import { useDebateProjection } from "./hooks/useDebateProjection";
import { useLayoutStable } from "./hooks/useLayoutStable";
import { useObserverAnchor } from "./hooks/useObserverAnchor";
import { useGradientProjection } from "./hooks/useGradientProjection";
import { useScrollOwnership } from "./hooks/useScrollOwnership";
import { useAutoScroll } from "./hooks/useAutoScroll";
import { MdxRenderer } from "./components/MdxRenderer";
import { bus } from "./bus";

const MotionBox = motion(Box);

export function App({ inspector }: { inspector?: any }) {
  const { prompt, setPrompt, loading, state, send, generate, replay } =
    useDebate(inspector?.inspect);

  const blocks = useDebateProjection();

  const scrollRef = React.useRef<HTMLDivElement | null>(null);

  // 1️⃣ Wait for layout (MDX + Mermaid) to stabilize
  const { ready: layoutReady } = useLayoutStable(scrollRef, blocks);

  // 2️⃣ Attach observer to bottom of content
  const { observerRef, observerMetrics } = useObserverAnchor(
    scrollRef,
    layoutReady,
  );

  // 3️⃣ Project observer geometry into gradient intensity
  const { intensity } = useGradientProjection(observerMetrics, layoutReady);

  // Extract scroll owner from state machine
  const scrollOwner =
    typeof state.value === "object" && "scroll" in state.value
      ? state.value.scroll
      : "machineOwned";

  // 4️⃣ Auto-scroll (returns restoringRef)
  const restoringRef = useAutoScroll(
    scrollRef,
    blocks.length,
    scrollOwner,
    layoutReady,
  );

  // 5️⃣ Ownership (suppressed while restoring)
  useScrollOwnership(send, scrollRef, restoringRef);

  return (
    <Box
      height="100vh"
      bg="#0d0f14"
      color="#e6e8ec"
      fontSize="17px"
      lineHeight="1.8"
      display="flex"
      flexDirection="column"
    >
      {/* Prompt Bar */}
      <Box
        position="sticky"
        top="0"
        zIndex="10"
        px="48px"
        py="20px"
        display="flex"
        gap="14px"
        backdropFilter="blur(12px)"
        bg="rgba(13,15,20,0.78)"
        borderBottom="1px solid rgba(255,255,255,0.05)"
      >
        <Input
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Zero trust in microservices…"
          bg="rgba(255,255,255,0.05)"
          border="1px solid rgba(255,255,255,0.08)"
          _focus={{ borderColor: "rgba(120,170,255,0.6)" }}
        />

        <Button
          onClick={generate}
          loading={loading}
          bg="rgba(255,255,255,0.08)"
          _hover={{ bg: "rgba(255,255,255,0.14)" }}
        >
          Generate
        </Button>

        <Button
          variant="outline"
          onClick={replay}
          disabled={!state.context.dialogue}
          border="1px solid rgba(255,255,255,0.1)"
        >
          Replay
        </Button>
      </Box>

      {/* Debate Stage Wrapper */}
      <Box flex="1" position="relative">
        {/* Scroll Viewport */}
        <Box
          ref={scrollRef}
          position="absolute"
          inset="0"
          overflowY="auto"
          data-testid="scroll-viewport"
          data-layout-ready={layoutReady ? "true" : "false"}
          data-scroll-owner={state.value.scroll}
        >
          {/* Content Wrapper */}
          <Box pt="160px" pb="160px">
            {blocks.map((block, i) => (
              <TurnRow key={block.id} block={block} index={i} />
            ))}

            {/* 2️⃣ Observer Anchor — must be last in content */}
            <Box
              ref={observerRef}
              data-testid="observer-anchor"
              height="1px"
              width="100%"
            />
          </Box>
        </Box>

        {/* 3️⃣ Bottom Gradient — fixed to viewport bottom */}
        <Box
          pointerEvents="none"
          data-testid="background-gradient"
          data-intensity={intensity.toFixed(4)}
          position="absolute"
          bottom="0"
          left="0"
          right="0"
          height="44px"
          bg={`linear-gradient(
            to top,
            rgba(120,170,255, ${0.32 * intensity}) 0%,
            rgba(120,170,255, ${0.18 * intensity}) 55%,
            rgba(120,170,255, 0) 100%
          )`}
        />
      </Box>
    </Box>
  );
}

function TurnRow({ block, index }: { block: any; index: number }) {
  return (
    <Box
      display="grid"
      gridTemplateColumns={{ base: "1fr", md: "1fr 1fr" }}
      px={{ base: "6vw", md: "8vw" }}
      py="100px"
      mt={index > 0 ? "-30px" : "0px"}
      position="relative"
    >
      <Pane
        side="left"
        speaker={block.speaker}
        active="security_engineer"
        block={block}
      />
      <Pane
        side="right"
        speaker={block.speaker}
        active="application_engineer"
        block={block}
      />
    </Box>
  );
}

function Pane({
  side,
  speaker,
  active,
  block,
}: {
  side: "left" | "right";
  speaker: string;
  active: string;
  block: any;
}) {
  const isActive = speaker === active;

  return (
    <Box
      display="flex"
      alignItems="center"
      justifyContent={
        side === "left" ? "flex-start" : { base: "flex-start", md: "flex-end" }
      }
      minH={{ base: "auto", md: "320px" }}
    >
      {isActive ? (
        <MeasuredBubble id={block.id} content={block.mdx} speaker={speaker} />
      ) : (
        <Box height={block.height ? `${block.height}px` : "0px"} />
      )}
    </Box>
  );
}

function MeasuredBubble({
  id,
  content,
  speaker,
}: {
  id: string;
  content: string;
  speaker: string;
}) {
  const ref = React.useRef<HTMLDivElement | null>(null);

  React.useEffect(() => {
    if (!ref.current) return;

    const el = ref.current;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        bus.emit("TURN_RENDERED", {
          id,
          height: entry.contentRect.height,
        });
      }
    });

    observer.observe(el);
    return () => observer.disconnect();
  }, [id]);

  const isSecurity = speaker === "security_engineer";

  return (
    <MotionBox
      data-testid="turn-bubble"
      ref={ref}
      transition={{ duration: 0.4, ease: "easeOut" }}
      width="70vw"
      maxW="1100px"
      fontSize="18px"
      borderLeft={isSecurity ? "3px solid rgba(120,170,255,0.35)" : undefined}
      borderRight={!isSecurity ? "3px solid rgba(255,180,120,0.35)" : undefined}
      pl={isSecurity ? "28px" : undefined}
      pr={!isSecurity ? "24px" : undefined}
      display={!isSecurity ? "flex" : "block"}
      flexDirection="column"
      alignItems={!isSecurity ? "flex-end" : undefined}
    >
      <Text
        fontSize="13px"
        letterSpacing="0.08em"
        textTransform="uppercase"
        opacity="0.6"
        mb="16px"
      >
        {isSecurity ? "Security Engineer" : "Application Engineer"}
      </Text>

      <Box width="100%" textAlign="left">
        <MdxRenderer content={content} />
      </Box>
    </MotionBox>
  );
}
</file>

</files>
