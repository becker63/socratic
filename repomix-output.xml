This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shared/
  schemas.ts
src/
  components/
    MdxRenderer.tsx
  fixtures/
    dialogue.json
  hooks/
    useAutoScroll.ts
    useDebate.ts
    useDebateProjection.ts
    useGradientProjection.ts
    useLayoutStable.ts
    useObserverAnchor.ts
    useScrollOwnership.ts
    useViewportHeight.ts
  types/
    socratic-global.d.ts
  App.tsx
  bus.ts
  debateMachine.ts
  main.tsx
  replay.ts
  testBridge.ts
test-results/
  .last-run.json
tests/
  utils/
    scrollTestUtils.ts
  scroll-centering.spec.ts
  scroll-visibility.spec.ts
  scroll.spec.ts
  scroll.stability.spec.ts
.gitignore
flake.lock
flake.nix
index.html
index.ts
package.json
playwright.config.ts
server.ts
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/hooks/useViewportHeight.ts">
import { useEffect, useState } from "react";

export function useViewportHeight(
  scrollRef: React.RefObject<HTMLElement | null>,
) {
  const [height, setHeight] = useState(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const update = () => setHeight(el.clientHeight);

    update();

    const ro = new ResizeObserver(update);
    ro.observe(el);

    window.addEventListener("resize", update);
    return () => {
      ro.disconnect();
      window.removeEventListener("resize", update);
    };
  }, [scrollRef]);

  return height;
}
</file>

<file path="src/types/socratic-global.d.ts">
import type { SocraticBridge } from "../testBridge";

declare global {
  interface Window {
    __socratic?: SocraticBridge;
  }
}

export {};
</file>

<file path="src/bus.ts">
import mitt from "mitt";
import type { Turn } from "../shared/schemas";

export type Pane = "security" | "application";

export type Events = {
  REPLAY_START: void;
  APPEND_TURN: Turn;
  REPLAY_COMPLETE: void;

  // NEW
  TURN_RENDERED: {
    id: string;
    height: number;
  };
};

export const bus = mitt<Events>();
</file>

<file path="tests/scroll-centering.spec.ts">
import { test, expect } from "@playwright/test";
import {
  waitForAppReady,
  appendTurns,
  getScrollOwner,
} from "./utils/scrollTestUtils";

/* ============================================================
   Scroll Centering E2E Tests (Instrumented)

   Validates geometric invariant:

   When machineOwned and content is appended,
   the newest block must be vertically centered
   inside the SCROLL VIEWPORT.

   This version logs full layout geometry so we
   can reason numerically instead of guessing.
============================================================ */

test.beforeEach(async ({ page }) => {
  page.on("console", (msg) => {
    console.log(`[browser:${msg.type()}]`, msg.text());
  });
});

test("machineOwned centers newest block after append", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);

  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");

  await expect
    .poll(async () => {
      return page.evaluate(() => {
        const el = document.querySelector(
          "[data-testid='scroll-viewport']",
        ) as HTMLElement;
        return el.scrollTop;
      });
    })
    .not.toBe(0);

  const geometry = await page.evaluate(() => {
    const viewport = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    const bubbles = Array.from(
      document.querySelectorAll("[data-testid='turn-bubble']"),
    ) as HTMLElement[];

    const spacer = document.querySelector(
      "[data-testid='bottom-spacer']",
    ) as HTMLElement | null;

    const observer = document.querySelector(
      "[data-testid='observer-anchor']",
    ) as HTMLElement | null;

    if (!viewport || bubbles.length === 0) {
      return { error: "Missing viewport or bubbles" };
    }

    const last = bubbles[bubbles.length - 1];

    const bubbleRect = last!.getBoundingClientRect();
    const viewportRect = viewport.getBoundingClientRect();

    const bubbleMid = bubbleRect.top + bubbleRect.height / 2;

    const viewportMid = viewportRect.top + viewport.clientHeight / 2;

    return {
      viewport: {
        clientHeight: viewport.clientHeight,
        scrollHeight: viewport.scrollHeight,
        scrollTop: viewport.scrollTop,
        rectTop: viewportRect.top,
        rectBottom: viewportRect.bottom,
      },
      window: {
        innerHeight: window.innerHeight,
      },
      bubble: {
        top: bubbleRect.top,
        height: bubbleRect.height,
        bottom: bubbleRect.bottom,
        midpoint: bubbleMid,
      },
      computed: {
        viewportMid,
        delta: Math.abs(bubbleMid - viewportMid),
      },
      spacer: spacer
        ? {
            height: spacer.getBoundingClientRect().height,
          }
        : null,
      observer: observer
        ? {
            top: observer.getBoundingClientRect().top,
          }
        : null,
      bubbleCount: bubbles.length,
    };
  });

  console.log("\n===== GEOMETRY SNAPSHOT =====");
  console.log(JSON.stringify(geometry, null, 2));
  console.log("================================\n");

  if ((geometry as any).error) {
    throw new Error((geometry as any).error);
  }

  expect((geometry as any).computed.delta).toBeLessThan(8);
});
</file>

<file path="tests/scroll-visibility.spec.ts">
import { test, expect } from "@playwright/test";
import {
  waitForAppReady,
  appendTurns,
  getScrollOwner,
} from "./utils/scrollTestUtils";

test.beforeEach(async ({ page }) => {
  page.on("console", (msg) => {
    console.log(`[browser:${msg.type()}]`, msg.text());
  });
});

test("machineOwned ensures last bubble is fully visible", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);

  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");

  // ðŸ”¥ Wait until scroll is actually at bottom
  await expect
    .poll(async () => {
      return await page.evaluate(() => {
        const viewport = document.querySelector(
          '[data-testid="scroll-viewport"]',
        ) as HTMLElement;

        return Math.abs(
          viewport.scrollHeight - viewport.scrollTop - viewport.clientHeight,
        );
      });
    })
    .toBeLessThan(5);

  const visibility = await page.evaluate(() => {
    const viewport = document.querySelector(
      '[data-testid="scroll-viewport"]',
    ) as HTMLElement;

    const bubbles = document.querySelectorAll('[data-testid="turn-bubble"]');

    const last = bubbles[bubbles.length - 1] as HTMLElement;

    const viewportRect = viewport.getBoundingClientRect();
    const bubbleRect = last.getBoundingClientRect();

    return {
      viewport: {
        top: viewportRect.top,
        bottom: viewportRect.bottom,
      },
      bubble: {
        top: bubbleRect.top,
        bottom: bubbleRect.bottom,
      },
      fullyVisible:
        bubbleRect.top >= viewportRect.top &&
        bubbleRect.bottom <= viewportRect.bottom,
    };
  });

  console.log("\n===== VISIBILITY SNAPSHOT =====");
  console.log(JSON.stringify(visibility, null, 2));
  console.log("================================\n");

  expect(visibility.fullyVisible).toBe(true);
});
</file>

<file path="tests/scroll.stability.spec.ts">
import { test, expect, type Page } from "@playwright/test";
import {
  waitForAppReady,
  appendTurns,
  getScrollOwner,
  isPhysicallyAtBottom,
} from "./utils/scrollTestUtils";

/* ============================================================
   Types
============================================================ */

type Sample = {
  scrollTop: number;
  scrollHeight: number;
  owner: string | null;
  intensity: number;
};

/* ============================================================
   Frame Sampler (Deterministic)
============================================================ */

async function sampleFrames(
  page: Page,
  frames: number = 100,
  intervalMs: number = 10,
): Promise<Sample[]> {
  return page.evaluate(
    async ({ frameCount, interval }) => {
      const el = document.querySelector(
        "[data-testid='scroll-viewport']",
      ) as HTMLElement | null;

      const grad = document.querySelector(
        "[data-testid='background-gradient']",
      ) as HTMLElement | null;

      if (!el) throw new Error("scroll-viewport not found");
      if (!grad) throw new Error("background-gradient not found");

      const samples: Sample[] = [];

      for (let i = 0; i < frameCount; i++) {
        await new Promise<void>((resolve) => setTimeout(resolve, interval));

        samples.push({
          scrollTop: el.scrollTop,
          scrollHeight: el.scrollHeight,
          owner: el.getAttribute("data-scroll-owner"),
          intensity: parseFloat(grad.getAttribute("data-intensity") ?? "0"),
        });
      }

      return samples;
    },
    { frameCount: frames, interval: intervalMs },
  );
}

/* ============================================================
   1ï¸âƒ£ Scroll Monotonicity
============================================================ */

test("auto-scroll is monotonic", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);
  await appendTurns(page, 6);

  const samples = await sampleFrames(page);

  expect(samples.length).toBeGreaterThan(1);

  for (let i = 1; i < samples.length; i++) {
    const prev = samples[i - 1]!;
    const curr = samples[i]!;

    expect(curr.scrollTop).toBeGreaterThanOrEqual(prev.scrollTop - 2);
  }
});

/* ============================================================
   2ï¸âƒ£ Ownership Stability
============================================================ */

test("machine ownership does not flip during auto-follow", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);
  await appendTurns(page, 6);

  const samples = await sampleFrames(page);

  const owners = new Set(samples.map((s) => s.owner));
  expect(owners).toEqual(new Set(["machineOwned"]));
});

/* ============================================================
   3ï¸âƒ£ Gradient Stability
============================================================ */

test("gradient does not flicker off during auto-follow", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);
  await appendTurns(page, 6);

  const samples = await sampleFrames(page);

  const intensities = samples.map((s) => s.intensity);

  const min = Math.min(...intensities);
  const max = Math.max(...intensities);

  expect(max).toBeGreaterThan(0.05);
  expect(min).toBeGreaterThan(0);
});

/* ============================================================
   4ï¸âƒ£ Layout Stabilization
============================================================ */

test("scrollHeight stabilizes quickly", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);
  await appendTurns(page, 6);

  const samples = await sampleFrames(page);

  let heightChanges = 0;

  for (let i = 1; i < samples.length; i++) {
    const prev = samples[i - 1]!;
    const curr = samples[i]!;

    if (Math.abs(curr.scrollHeight - prev.scrollHeight) > 5) {
      heightChanges++;
    }
  }

  expect(heightChanges).toBeLessThan(3);
});

/* ============================================================
   5ï¸âƒ£ End State Contract
============================================================ */

test("auto-follow ends at bottom and machineOwned", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);
  await appendTurns(page, 6);

  await expect.poll(() => isPhysicallyAtBottom(page)).toBeTruthy();
  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");
});
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="index.html">
<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Minimal Bun + React</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
</file>

<file path="index.ts">
console.log("Hello via Bun!");
</file>

<file path="playwright.config.ts">
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./tests",
  timeout: 30_000,
  use: {
    headless: true,
    baseURL: "http://127.0.0.1:5173",
    browserName: "chromium",
    launchOptions: {
      executablePath: process.env.PLAYWRIGHT_CHROMIUM_PATH,
    },
  },
  webServer: {
    command: "bunx vite --host 127.0.0.1 --port 5173",
    url: "http://127.0.0.1:5173",
    reuseExistingServer: !process.env.CI,
    timeout: 60_000,
  },
});
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001",
    },
  },
});
</file>

<file path="src/hooks/useLayoutStable.ts">
import { useEffect, useState } from "react";

/**
 * useLayoutStable
 *
 * Responsibility:
 * Detect when scroll content has stopped resizing for a short window.
 *
 * This is necessary because:
 * - MDX rendering
 * - Mermaid diagrams
 * - dynamic height measurement
 *
 * all cause asynchronous layout changes.
 *
 * We mark layout as "ready" only after no ResizeObserver events
 * fire for `settleMs` milliseconds.
 */
export function useLayoutStable(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  blocks: unknown[],
  settleMs: number = 300,
) {
  // True once layout has fully settled
  const [ready, setReady] = useState(false);

  // Incremented whenever layout re-stabilizes
  // Useful if consumers want to react to new stable cycles
  const [version, setVersion] = useState(0);

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    // We observe the first child (content wrapper)
    const content = el.firstElementChild as HTMLElement | null;
    if (!content) return;

    // Whenever blocks change, layout is considered unstable again
    setReady(false);

    let timeout: number | null = null;

    const observer = new ResizeObserver(() => {
      // Reset debounce window on every resize
      if (timeout) window.clearTimeout(timeout);

      timeout = window.setTimeout(() => {
        // Layout has been stable for settleMs
        setReady(true);
        setVersion((v) => v + 1);
      }, settleMs);
    });

    observer.observe(content);

    return () => {
      observer.disconnect();
      if (timeout) window.clearTimeout(timeout);
    };
  }, [scrollRef, blocks.length, settleMs]);

  return { ready, version };
}
</file>

<file path="src/hooks/useObserverAnchor.ts">
import { useEffect, useRef, useState } from "react";

/**
 * ObserverMetrics
 *
 * These are geometry values derived from the DOM.
 * They are intentionally minimal â€” just enough to drive projection logic
 * (e.g., gradient intensity) without leaking full layout complexity.
 */
export type ObserverMetrics = {
  /**
   * The vertical midpoint of the anchor element,
   * expressed in viewport coordinates (relative to the window).
   *
   * Used to determine how close the anchor is to the bottom
   * of the visible scroll region.
   */
  midYInViewport: number;

  /**
   * The bottom of the anchor element,
   * expressed in content coordinates (relative to the scroll container).
   *
   * This is useful if we ever want to reason about
   * content-relative positioning instead of viewport-relative.
   */
  bottomInContent: number;

  /**
   * The visible height of the scroll viewport.
   * Used to normalize distance calculations.
   */
  viewportHeight: number;
};

/**
 * useObserverAnchor
 *
 * Responsibility:
 * ----------------
 * Attach a physical "anchor" element to the bottom of the scroll content
 * and continuously measure its spatial relationship to the viewport.
 *
 * This hook does NOT make decisions.
 * It only measures geometry and exposes it.
 *
 * Design Principles:
 * ------------------
 * 1. Only activate after layout has stabilized.
 * 2. Avoid leaking DOM complexity to consumers.
 * 3. Keep geometry calculations centralized and minimal.
 * 4. React to both scroll and window resize.
 */
export function useObserverAnchor(
  /**
   * Ref to the scrollable viewport container.
   */
  scrollRef: React.RefObject<HTMLDivElement | null>,

  /**
   * True only after layout (MDX, Mermaid, content height)
   * has fully stabilized.
   *
   * We do not measure geometry before layout is ready,
   * because early reads would be incorrect and noisy.
   */
  layoutReady: boolean,
) {
  /**
   * Ref to the invisible anchor element.
   *
   * This element is placed at the bottom of the content
   * and acts as a physical probe.
   */
  const observerRef = useRef<HTMLDivElement | null>(null);

  /**
   * The latest computed geometry metrics.
   * Null until first measurement occurs.
   */
  const [metrics, setMetrics] = useState<ObserverMetrics | null>(null);

  useEffect(() => {
    /**
     * Do nothing until layout is stable.
     * Prevents reading incomplete DOM geometry.
     */
    if (!layoutReady) return;

    const scroller = scrollRef.current;
    const observer = observerRef.current;

    if (!scroller || !observer) return;

    /**
     * update()
     *
     * Reads live DOM geometry and projects it into
     * a minimal, normalized metric shape.
     *
     * This is intentionally the ONLY place that
     * DOM layout reads occur for this concern.
     */
    const update = () => {
      /**
       * getBoundingClientRect gives viewport-relative coordinates.
       */
      const scrollerRect = scroller.getBoundingClientRect();
      const observerRect = observer.getBoundingClientRect();

      /**
       * Midpoint of the anchor in viewport space.
       *
       * We use midpoint instead of top/bottom directly
       * to create smoother projection behavior.
       */
      const midYInViewport = observerRect.top + observerRect.height / 2;

      /**
       * Bottom of anchor in content space.
       *
       * offsetTop is relative to offsetParent,
       * which here corresponds to the scroll content wrapper.
       */
      const bottomInContent = observer.offsetTop + observer.offsetHeight;

      /**
       * Visible height of scroll viewport.
       */
      const viewportHeight = scroller.clientHeight;

      setMetrics({
        midYInViewport,
        bottomInContent,
        viewportHeight,
      });
    };

    /**
     * Initial measurement.
     */
    update();

    /**
     * Listen to scroll events.
     * Passive because we do not preventDefault.
     */
    scroller.addEventListener("scroll", update, { passive: true });

    /**
     * Also listen to window resize,
     * since viewport height changes affect projections.
     */
    window.addEventListener("resize", update);

    return () => {
      scroller.removeEventListener("scroll", update);
      window.removeEventListener("resize", update);
    };
  }, [layoutReady, scrollRef]);

  /**
   * Return:
   * - observerRef â†’ attach to bottom anchor element
   * - observerMetrics â†’ continuously updated geometry signal
   *
   * Consumers (like gradient projection) should treat
   * this as read-only physical telemetry.
   */
  return { observerRef, observerMetrics: metrics };
}
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { ChakraProvider, defaultSystem } from "@chakra-ui/react";
import { App } from "./App";
import { installTestBridge } from "./testBridge";

let inspector: ReturnType<
  typeof import("@statelyai/inspect").createBrowserInspector
> | null = null;

if (import.meta.env.DEV) {
  const { createBrowserInspector } = await import("@statelyai/inspect");

  inspector = createBrowserInspector();
}

installTestBridge();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ChakraProvider value={defaultSystem}>
      <App inspector={inspector} />
    </ChakraProvider>
  </React.StrictMode>,
);
</file>

<file path="src/replay.ts">
import type { Dialogue } from "../shared/schemas";
import { bus } from "./bus";

const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

/**
 * Global pacing control.
 * 1   = normal
 * 1.5 = slower
 * 2   = cinematic slow
 * 0.5 = fast
 */
const REPLAY_SPEED = 1.6;

function computeDelay(mdx: string) {
  const words = mdx.split(/\s+/).filter(Boolean).length;

  // Base reading rhythm
  const base = 1400; // initial pause before reading
  const perWord = 45; // reading pacing per word

  let delay = base + words * perWord;

  // Visual soak time
  if (mdx.includes("```mermaid")) {
    delay += 2000; // diagrams deserve longer pause
  }

  if (mdx.includes("```") && !mdx.includes("```mermaid")) {
    delay += 1400; // code blocks get extra time
  }

  return delay * REPLAY_SPEED;
}

export async function replayDialogue(dialogue: Dialogue) {
  bus.emit("REPLAY_START");

  for (const turn of dialogue.turns) {
    console.log("[bus] APPEND_TURN");
    bus.emit("APPEND_TURN", turn);

    const delay = computeDelay(turn.mdx);

    await sleep(delay);
  }

  bus.emit("REPLAY_COMPLETE");
}
</file>

<file path="src/testBridge.ts">
// src/testBridge.ts
import { bus } from "./bus";

/* ------------------------------------------------------------
   Machine Log Shape
------------------------------------------------------------ */

export type MachineLogEvent = {
  t: number;
  phase: "event" | "transition";
  event?: string;
  value: unknown;
  context: unknown;
};

/* ------------------------------------------------------------
   Bridge Interface
------------------------------------------------------------ */

export interface SocraticBridge {
  emit: (type: string, payload?: unknown) => void;
  machineEvents: MachineLogEvent[];
  onMachineEvent: (payload: MachineLogEvent) => void;
  clearMachineEvents: () => void;
}

/* ------------------------------------------------------------
   Global Window Augmentation
------------------------------------------------------------ */

declare global {
  interface Window {
    __socratic?: SocraticBridge;
  }
}

/* ------------------------------------------------------------
   Install Bridge
------------------------------------------------------------ */

export function installTestBridge() {
  // Only install in dev or test mode
  if (!import.meta.env.DEV && import.meta.env.MODE !== "test") return;

  const bridge: SocraticBridge = {
    emit: (type, payload) => {
      bus.emit(type as any, payload);
    },

    machineEvents: [],

    onMachineEvent(payload) {
      bridge.machineEvents.push(payload);
    },

    clearMachineEvents() {
      bridge.machineEvents.length = 0;
    },
  };

  window.__socratic = bridge;
}
</file>

<file path="tests/utils/scrollTestUtils.ts">
import type { Page } from "@playwright/test";
import type { Turn } from "../../shared/schemas";

/* ============================================================
   Scroll Test Utilities

   These helpers are shared across:

   - scroll.spec.ts
   - scroll-centering.spec.ts

   They intentionally abstract DOM plumbing so tests
   read like behavioral specifications instead of
   browser scripting.
============================================================ */

/* ------------------------------------------------------------
   Turn Factory
------------------------------------------------------------ */

/**
 * Creates a tall turn so that scrolling is meaningful.
 *
 * Each turn contains enough repeated text to produce
 * vertical overflow in the scroll container.
 *
 * This guarantees:
 * - scrollHeight > clientHeight
 * - scrolling physics are observable
 */
export function turn(i: number): Turn {
  return {
    speaker: i % 2 === 0 ? "security_engineer" : "application_engineer",
    mdx: `Turn ${i}\n\n` + "word ".repeat(200),
  };
}

/* ------------------------------------------------------------
   App Readiness
------------------------------------------------------------ */

/**
 * Waits until:
 *
 * 1) The test bridge is installed (window.__socratic exists)
 * 2) The scroll viewport is mounted in the DOM
 *
 * This prevents race conditions where:
 * - React has not mounted yet
 * - The machine has not initialized
 */
export async function waitForAppReady(page: Page) {
  await page.waitForFunction(() => !!window.__socratic);
  await page.waitForSelector("[data-testid='scroll-viewport']");
}

/* ------------------------------------------------------------
   Content Growth
------------------------------------------------------------ */

/**
 * Emits APPEND_TURN events through the test bridge.
 *
 * This simulates replay-driven content growth
 * without invoking the actual replay actor timing.
 *
 * We intentionally bypass delay mechanics
 * so tests run deterministically.
 */
export async function appendTurns(page: Page, count: number) {
  for (let i = 0; i < count; i++) {
    await page.evaluate((payload: Turn) => {
      window.__socratic?.emit("APPEND_TURN", payload);
    }, turn(i));
  }
}

/* ------------------------------------------------------------
   Manual Scroll Simulation
------------------------------------------------------------ */

/**
 * Simulates a user scroll by:
 *
 * 1) Mutating scrollTop
 * 2) Manually dispatching a scroll event
 *
 * Why dispatch?
 * Because ownership logic listens to the scroll event,
 * not scrollTop mutation alone.
 */
export async function manualScroll(page: Page, delta: number) {
  await page.evaluate((amount) => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    // Simulate real wheel intent
    el.dispatchEvent(
      new WheelEvent("wheel", {
        deltaY: amount,
        bubbles: true,
      }),
    );

    // Apply scroll movement
    el.scrollTop += amount;

    el.dispatchEvent(new Event("scroll"));
  }, delta);
}

/**
 * Force scroll to bottom.
 *
 * Used to simulate a user returning control to the machine.
 *
 * Equivalent invariant:
 *   scrollTop + clientHeight â‰ˆ scrollHeight
 */
export async function scrollToBottom(page: Page) {
  await page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    el.scrollTop = el.scrollHeight;
    el.dispatchEvent(new Event("scroll"));
  });
}

/* ------------------------------------------------------------
   Ownership Introspection
------------------------------------------------------------ */

/**
 * Reads scroll ownership from DOM attribute.
 *
 * This reflects XState's parallel "scroll" region.
 *
 * We intentionally assert via DOM rather than machine snapshot
 * so tests validate actual UI integration.
 */
export async function getScrollOwner(page: Page) {
  return page.getByTestId("scroll-viewport").getAttribute("data-scroll-owner");
}

/* ------------------------------------------------------------
   Physical Scroll Geometry
------------------------------------------------------------ */

/**
 * Determines whether the viewport is physically at bottom.
 *
 * Geometry:
 *
 *   scrollTop      â†’ distance from top
 *   clientHeight   â†’ viewport height
 *   scrollHeight   â†’ total content height
 *
 * Bottom invariant:
 *
 *   scrollTop + clientHeight â‰ˆ scrollHeight
 *
 * Due to subpixel rounding and layout jitter,
 * we allow a tolerance of 5px.
 */
export async function isPhysicallyAtBottom(page: Page) {
  return page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    const bottomEdge = el.scrollTop + el.clientHeight;
    const contentBottom = el.scrollHeight;

    return bottomEdge >= contentBottom - 5;
  });
}

/* ------------------------------------------------------------
   Centering Geometry (New Invariant)
------------------------------------------------------------ */

/**
 * Measures how far the newest bubble midpoint
 * deviates from viewport midpoint.
 *
 * Used to validate centering behavior.
 *
 * Invariant:
 *
 *   abs(bubbleMid - viewportMid) < tolerance
 *
 * ASCII sketch:
 *
 *   | viewport top
 *   |
 *   |     [ last bubble ]
 *   |         *
 *   |         | midpoint
 *   |
 *   |-----------------------
 *          viewport mid
 */
export async function getLastBubbleMidpointDelta(page: Page) {
  return page.evaluate(() => {
    const bubbles = Array.from(
      document.querySelectorAll("[data-testid='turn-bubble']"),
    ) as HTMLElement[];

    if (bubbles.length === 0) return null;

    const last = bubbles[bubbles.length - 1];
    const rect = last!.getBoundingClientRect();

    const bubbleMid = rect.top + rect.height / 2;
    const viewportMid = window.innerHeight / 2;

    return Math.abs(bubbleMid - viewportMid);
  });
}
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1767039857,
        "narHash": "sha256-vNpUSpF5Nuw8xvDLj2KCwwksIbjua2LZCqhV1LNRDns=",
        "owner": "NixOS",
        "repo": "flake-compat",
        "rev": "5edf11c44bc78a0d334f6334cdaf7d60d732daab",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "git-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1772024342,
        "narHash": "sha256-+eXlIc4/7dE6EcPs9a2DaSY3fTA9AE526hGqkNID3Wg=",
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "6e34e97ed9788b17796ee43ccdbaf871a5c2b476",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "git-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1770073757,
        "narHash": "sha256-Vy+G+F+3E/Tl+GMNgiHl9Pah2DgShmIUBJXmbiQPHbI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "47472570b1e607482890801aeaf29bfb749884f6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1771848320,
        "narHash": "sha256-0MAd+0mun3K/Ns8JATeHT1sX28faLII5hVLq0L3BdZU=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2fc6539b481e1d2569f25f8799236694180c0993",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "git-hooks": "git-hooks",
        "nixpkgs": "nixpkgs_2"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "moduleDetection": "force",
    "verbatimModuleSyntax": true,
    "allowImportingTsExtensions": true,

    "noEmit": true,

    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "tests/**/*.ts"]
}
</file>

<file path="src/components/MdxRenderer.tsx">
import React from "react";
import { Box } from "@chakra-ui/react";
import { MarkdownHooks } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeMermaid from "rehype-mermaid";

export function MdxRenderer({ content }: { content: string }) {
  return (
    <Box
      css={{
        "& p": { marginBottom: "1rem", lineHeight: 1.8 },
        "& ul": { paddingLeft: "1.4rem", marginBottom: "1rem" },
        "& li": { marginBottom: "0.4rem" },
        "& pre": {
          background: "rgba(255,255,255,0.04)",
          padding: "1rem",
          borderRadius: "12px",
          border: "1px solid rgba(255,255,255,0.06)",
          overflowX: "auto",
          fontSize: "0.9rem",
        },
        "& code": {
          background: "rgba(255,255,255,0.08)",
          padding: "0.2rem 0.4rem",
          borderRadius: "6px",
        },
        "& svg": {
          background: "rgba(255,255,255,0.03)",
          borderRadius: "12px",
          padding: "0.5rem",
        },
      }}
    >
      <MarkdownHooks
        key={content}
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[[rehypeMermaid, { strategy: "inline-svg" }]]}
      >
        {content}
      </MarkdownHooks>
    </Box>
  );
}
</file>

<file path="src/fixtures/dialogue.json">
{
  "topic": "Zero trust in microservices",
  "turns": [
    {
      "speaker": "security_engineer",
      "mdx": "I keep picturing a pager at 3am: tokens stale, mesh rules mismatched, services silent. Zero trust is right, but fragile if half-rolled. We need clear boundaries and single sources of truth for identity and policy.\n\n```mermaid\nflowchart LR\nClient-->Gateway\nGateway-->AuthZ\nGateway-->SvcA\nAuthZ-->IDP\n```"
    },
    {
      "speaker": "application_engineer",
      "mdx": "I hear the pager fear. I also care about shipping and feedback loops. We can validate identity locally and still move fast. For dev flow, passing a token is easy:\n\n```bash\ncurl -H 'Authorization: Bearer $TOKEN' https://svc-a.internal/endpoint\n```\n\nShort tokens are reversible and fast to test."
    },
    {
      "speaker": "security_engineer",
      "mdx": "Local checks help, but trust needs enforcement at the data path. Sidecars and a policy engine reduce blast radius. Make auth decisions consistent and observable so we don't get divergent behavior across environments.\n\n```mermaid\nflowchart LR\nApp-->Sidecar\nSidecar-->mTLS\nSidecar-->OPA\nOPA-->CA\n```"
    },
    {
      "speaker": "application_engineer",
      "mdx": "Sidecars add ops overhead. Developers will resist if they have to write policies for every route. We should provide sane defaults and let teams opt-in for stricter rules. Example policy skeleton to start from:\n\n```yaml\nselector: 'svc-a'\nallow: ['svc-b']\nmethods: ['GET','POST']\n```"
    },
    {
      "speaker": "security_engineer",
      "mdx": "Defaults are good, but we must plan revocation and audit. Short-lived certs plus a revocation channel keeps compromised workloads limited. Also log decisions centrally so incident triage isn't guessing who accepted which token.\n\n```mermaid\nflowchart LR\nIDP-->Revoker\nRevoker-->Proxy\nProxy-->Service\nService-->Audit\n```"
    },
    {
      "speaker": "application_engineer",
      "mdx": "Agreed on logs and short certs. My worry: if we lock everything down too fast we slow feature work. Let's phase: adopt identity + audit first, then enforce authz on critical paths, then widen. Keep rollback simple and use feature flags for gating."
    },
    {
      "speaker": "security_engineer",
      "mdx": "Phased approach works if boundaries are strict. Identity isn't authorization. You still need fine-grained checks at ingress to sensitive services. Make it easy to add checks with middleware that fails closed by default, and surface test harnesses.\n\n```python\ndef authz_middleware(req):\n    token = req.headers.get('Authorization')\n    if not check(token, req.path):\n        return Response(status=403)\n    return next(req)\n```"
    },
    {
      "speaker": "application_engineer",
      "mdx": "If middleware is boilerplate, generate it. Tooling is the sweet spot: SDKs, templates, and CI helpers that inject sidecar configs. Automate the repetitive stuff so teams adopt without reinventing.\n\n```mermaid\nflowchart LR\nCI-->Inject\nInject-->Cluster\nCluster-->App\n```"
    },
    {
      "speaker": "security_engineer",
      "mdx": "We also need SLOs and tracing for the auth path. Authz latency spikes can cascade. Track authz_latency, deny_rate, token_validation_errors. Alert on growth and add circuit breakers to avoid taking down dependent services during failures."
    },
    {
      "speaker": "application_engineer",
      "mdx": "Operational controls make me happier. We still need runtime flexibility: feature toggles and gradual rollouts let us tighten rules without blocking customers. A simple flag file per-service is low friction:\n\n```yaml\nfeature_flags:\n  zero_trust_enforce: false\n  authz_strict: 'canary'\n```"
    },
    {
      "speaker": "security_engineer",
      "mdx": "Flags are useful, but they must default to safe states and be gated by canaries plus automated rollback. Also tie flags to audit logs and require approval for global flips. Otherwise a mis-set flag causes a broad outage at 3am."
    },
    {
      "speaker": "application_engineer",
      "mdx": "Okay, here's a pragmatic plan: start with identity + central audit, scaffold middleware and SDKs, enable short-lived creds, and gate strict authz by canary + feature flag. We'll automate rollbacks and provide templates so devs donâ€™t fight guardrails."
    }
  ]
}
</file>

<file path="src/hooks/useDebate.ts">
import { useState, useEffect, useMemo } from "react";
import { useMachine } from "@xstate/react";
import {
  PromptRequestSchema,
  DialogueSchema,
  type Dialogue,
} from "../../shared/schemas";
import fixtureData from "../fixtures/dialogue.json";
import { debateMachine } from "../debateMachine";

const USE_STATIC_FIXTURE = true;

export function useDebate(inspect?: any) {
  const [prompt, setPrompt] = useState("Zero trust in microservices");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // actor is the authoritative runtime instance
  const [state, originalSend, actor] = useMachine(debateMachine, {
    inspect,
  });

  /* ------------------------------------------------------------
     Pre-Transition Logging (Event Boundary)
  ------------------------------------------------------------ */

  // Wrap send so we log every event entering the machine
  const send = useMemo(() => {
    return (event: Parameters<typeof originalSend>[0]) => {
      const before = actor.getSnapshot();

      const payload = {
        t: performance.now(),
        phase: "event",
        event: event.type,
        value: before.value,
        context: before.context,
      };

      console.log("[machine event]", payload);

      if (typeof window !== "undefined") {
        const w = window as any;
        w.__socratic?.onMachineEvent?.(payload);
      }

      originalSend(event);
    };
  }, [originalSend, actor]);

  /* ------------------------------------------------------------
     Post-Transition Logging (State Boundary)
  ------------------------------------------------------------ */

  useEffect(() => {
    if (!actor) return;

    const sub = actor.subscribe((snapshot) => {
      const payload = {
        t: performance.now(),
        phase: "transition",
        value: snapshot.value,
        context: snapshot.context,
      };

      console.log("[machine transition]", payload);

      if (typeof window !== "undefined") {
        const w = window as any;
        w.__socratic?.onMachineEvent?.(payload);
      }
    });

    return () => sub.unsubscribe();
  }, [actor]);

  /* ------------------------------------------------------------
     Domain Commands
  ------------------------------------------------------------ */

  async function generate() {
    setLoading(true);
    setError(null);

    try {
      let parsed: Dialogue;

      if (USE_STATIC_FIXTURE) {
        parsed = DialogueSchema.parse(fixtureData);
      } else {
        const body = PromptRequestSchema.parse({ prompt });

        const resp = await fetch("/api/dialogue", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(body),
        });

        if (!resp.ok) throw new Error(await resp.text());

        parsed = DialogueSchema.parse(await resp.json());
      }

      send({ type: "GENERATE", dialogue: parsed });
    } catch (e) {
      setError(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  }

  function replay() {
    send({ type: "REPLAY" });
  }

  return {
    prompt,
    setPrompt,
    loading,
    error,
    send, // wrapped send (instrumented)
    state,
    generate,
    replay,
  };
}
</file>

<file path="src/hooks/useDebateProjection.ts">
import { useEffect, useState } from "react";
import type { Turn } from "../../shared/schemas";
import { bus } from "../bus";

/**
 * LayoutBlock
 *
 * UI-projected representation of a Turn.
 * Adds:
 * - stable unique id
 * - measured height (for mirrored panes)
 */
export type LayoutBlock = Turn & {
  id: string;
  height?: number;
};

/**
 * useDebateProjection
 *
 * Responsibility:
 * Project domain events (via bus) into renderable UI blocks.
 *
 * This is an event â†’ view-model adapter.
 * It keeps UI concerns (ids, measured height)
 * separate from the state machine.
 */
export function useDebateProjection() {
  const [blocks, setBlocks] = useState<LayoutBlock[]>([]);

  useEffect(() => {
    // Clear projection on replay start
    function onStart() {
      setBlocks([]);
    }

    // Append new turn to projection
    function onAppend(turn: Turn) {
      setBlocks((prev) => [
        ...prev,
        {
          ...turn,
          id: crypto.randomUUID(), // stable render key
        },
      ]);
    }

    // Update measured height once bubble renders
    function onRendered({ id, height }: { id: string; height: number }) {
      setBlocks((prev) =>
        prev.map((b) => (b.id === id ? { ...b, height } : b)),
      );
    }

    bus.on("REPLAY_START", onStart);
    bus.on("APPEND_TURN", onAppend);
    bus.on("TURN_RENDERED", onRendered);

    return () => {
      bus.off("REPLAY_START", onStart);
      bus.off("APPEND_TURN", onAppend);
      bus.off("TURN_RENDERED", onRendered);
    };
  }, []);

  return blocks;
}
</file>

<file path="src/debateMachine.ts">
// src/machines/debateMachine.ts
import { setup, assign, fromPromise } from "xstate";
import type { Dialogue } from "../shared/schemas";
import { replayDialogue } from "./replay";

/* ------------------------------------------------------------
   Machine
------------------------------------------------------------ */

export const debateMachine = setup({
  types: {
    context: {} as {
      dialogue: Dialogue | null;
      error: string | null;
    },
    events: {} as
      | { type: "GENERATE"; dialogue: Dialogue }
      | { type: "REPLAY" }
      | { type: "USER_SCROLLED_UP" }
      | { type: "USER_AT_BOTTOM" }
      | { type: "FAIL"; error: string },
  },

  actors: {
    replayActor: fromPromise(
      async ({ input }: { input: { dialogue: Dialogue } }) => {
        await replayDialogue(input.dialogue);
      },
    ),
  },
}).createMachine({
  id: "debate",
  type: "parallel",

  context: {
    dialogue: null,
    error: null,
  },

  states: {
    /* ------------------------------------------------------------
       Lifecycle Control Plane
    ------------------------------------------------------------ */

    lifecycle: {
      initial: "idle",

      states: {
        idle: {
          on: {
            GENERATE: {
              target: "ready",
              actions: assign({
                dialogue: ({ event }) => event.dialogue,
                error: () => null,
              }),
            },
          },
        },

        ready: {
          on: {
            REPLAY: {
              target: "replaying",
            },
          },
        },

        replaying: {
          invoke: {
            src: "replayActor",
            input: ({ context }) => {
              if (!context.dialogue) {
                throw new Error("No dialogue available");
              }
              return { dialogue: context.dialogue };
            },
            onDone: {
              target: "complete",
            },
            onError: {
              target: "error",
              actions: assign({
                error: ({ event }) => String(event.error),
              }),
            },
          },
        },

        complete: {
          on: {
            REPLAY: {
              target: "replaying",
            },
          },
        },

        error: {
          on: {
            GENERATE: {
              target: "ready",
              actions: assign({
                dialogue: ({ event }) => event.dialogue,
                error: () => null,
              }),
            },
          },
        },
      },
    },

    /* ------------------------------------------------------------
       Scroll Ownership Control Plane
    ------------------------------------------------------------ */

    scroll: {
      initial: "machineOwned",

      states: {
        machineOwned: {
          on: {
            USER_SCROLLED_UP: {
              target: "userOwned",
            },
          },
        },

        userOwned: {
          on: {
            USER_AT_BOTTOM: {
              target: "machineOwned",
            },
          },
        },
      },
    },
  },
});
</file>

<file path="test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path="flake.nix">
{
  description = "Bun + Vite + Playwright + Pre-commit multi-platform dev shell";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    git-hooks.url = "github:cachix/git-hooks.nix";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
      git-hooks,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };

        preCommit = git-hooks.lib.${system}.run {
          src = ./.;
          hooks = {
            # Secret scanning
            trufflehog.enable = true;
            ripsecrets.enable = true;

            # Hygiene
            nixfmt.enable = true;
            end-of-file-fixer.enable = true;
            trim-trailing-whitespace.enable = true;
          };
        };
      in
      {
        checks.pre-commit-check = preCommit;

        devShells.default = pkgs.mkShell {
          packages = [
            pkgs.bun
            pkgs.chromium
          ]
          ++ preCommit.enabledPackages;

          shellHook = ''
            ${preCommit.shellHook}

            export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
            export PLAYWRIGHT_CHROMIUM_PATH=${pkgs.chromium}/bin/chromium
            export PLAYWRIGHT_BROWSERS_PATH=0
          '';
        };
      }
    );
}
</file>

<file path="shared/schemas.ts">
// shared/schemas.ts
import { z } from "zod";

/* ============================================================
   Constants
============================================================ */

// Balanced for 12 turns (keeps latency reasonable)
const MAX_MDX_LENGTH = 850; // Slightly increased from 500
const MAX_MERMAID_BLOCK_LENGTH = 350; // Small bump for clarity
const MAX_TOPIC_LENGTH = 160;

/* ============================================================
   Prompt Input
============================================================ */

export const PromptRequestSchema = z.object({
  prompt: z.string().min(1).max(300),
});

/* ============================================================
   Speakers
============================================================ */

export const SpeakerSchema = z.enum([
  "security_engineer",
  "application_engineer",
]);

export type Speaker = z.infer<typeof SpeakerSchema>;

/* ============================================================
   Mermaid Validation
============================================================ */

function validateMermaidBlocks(text: string) {
  const blocks = text.match(/```mermaid[\s\S]*?```/g);
  if (!blocks) return true;

  return blocks.every((block) => {
    if (block.length > MAX_MERMAID_BLOCK_LENGTH) return false;

    if (!block.includes("flowchart LR")) return false;

    if (
      block.includes("click ") ||
      block.includes("classDef") ||
      block.includes("note over") ||
      block.includes("sequenceDiagram") ||
      block.includes("subgraph")
    ) {
      return false;
    }

    return true;
  });
}

/* ============================================================
   Turn Schema
============================================================ */

export const TurnSchema = z.object({
  speaker: SpeakerSchema,
  mdx: z.string().min(1).max(MAX_MDX_LENGTH).refine(validateMermaidBlocks, {
    message: "Invalid or oversized mermaid diagram block",
  }),
});

export type Turn = z.infer<typeof TurnSchema>;

/* ============================================================
   Dialogue Root
============================================================ */

export const DialogueSchema = z.object({
  topic: z.string().min(1).max(MAX_TOPIC_LENGTH),

  // Exactly 12 turns for a strong visual + narrative arc
  turns: z.array(TurnSchema).length(12),
});

export type Dialogue = z.infer<typeof DialogueSchema>;
</file>

<file path="src/hooks/useAutoScroll.ts">
import { useLayoutEffect, useRef } from "react";

function easeOutCubic(t: number) {
  return 1 - Math.pow(1 - t, 3);
}

export function useAutoScroll(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  layoutVersion: number,
  scrollOwner: "machineOwned" | "userOwned",
  layoutReady: boolean,
) {
  const prevVersionRef = useRef(layoutVersion);
  const pendingScrollRef = useRef(false);
  const restoringRef = useRef(false);
  const rafRef = useRef<number | null>(null);

  const ownerRef = useRef(scrollOwner);
  ownerRef.current = scrollOwner;

  useLayoutEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const cancel = () => {
      if (rafRef.current != null) {
        cancelAnimationFrame(rafRef.current);
        rafRef.current = null;
      }
      restoringRef.current = false;
    };

    /* ------------------------------------------------------------
       Phase 1 â€” Detect New Stable Layout Cycle
    ------------------------------------------------------------ */

    if (layoutVersion !== prevVersionRef.current) {
      prevVersionRef.current = layoutVersion;

      if (scrollOwner === "machineOwned") {
        pendingScrollRef.current = true;
      }
    }

    /* ------------------------------------------------------------
       Phase 2 â€” Execute Scroll After Stable Commit
    ------------------------------------------------------------ */

    if (
      layoutReady &&
      pendingScrollRef.current &&
      scrollOwner === "machineOwned"
    ) {
      pendingScrollRef.current = false;

      cancel();

      const isTest = import.meta.env.MODE === "test";

      // ðŸ”¥ Wait two frames for DOM + motion flush
      rafRef.current = requestAnimationFrame(() => {
        rafRef.current = requestAnimationFrame(() => {
          const currentEl = scrollRef.current;
          if (!currentEl || ownerRef.current !== "machineOwned") {
            cancel();
            return;
          }

          // ðŸ”¥ NEW: Prevent scroll cycle when no overflow exists
          if (currentEl.scrollHeight <= currentEl.clientHeight) {
            restoringRef.current = false;
            return;
          }

          // ðŸ”¥ Recompute AFTER settle
          const start = currentEl.scrollTop;
          const target = Math.max(
            0,
            currentEl.scrollHeight - currentEl.clientHeight,
          );

          const distance = target - start;

          if (Math.abs(distance) < 1) {
            restoringRef.current = false;
            return;
          }

          restoringRef.current = true;

          if (isTest) {
            currentEl.scrollTop = target;
            restoringRef.current = false;
            return;
          }

          const duration = 700;
          const startTime = performance.now();

          const animate = (now: number) => {
            const elNow = scrollRef.current;
            if (!elNow || ownerRef.current !== "machineOwned") {
              cancel();
              return;
            }

            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeOutCubic(progress);

            elNow.scrollTop = start + distance * eased;

            if (progress < 1) {
              rafRef.current = requestAnimationFrame(animate);
            } else {
              elNow.scrollTop = target;
              cancel();
            }
          };

          rafRef.current = requestAnimationFrame(animate);
        });
      });
    }

    return () => cancel();
  }, [layoutVersion, layoutReady, scrollOwner, scrollRef]);

  return restoringRef;
}
</file>

<file path="src/hooks/useGradientProjection.ts">
import { useEffect, useRef, useState } from "react";

export function useGradientProjection(
  scrollRef: React.RefObject<HTMLDivElement | null>,
  layoutReady: boolean,
  scrollOwner: "machineOwned" | "userOwned",
  restoringRef: React.MutableRefObject<boolean>,
  maxDistance: number = 400,
) {
  const [intensity, setIntensity] = useState(1);

  const GRACE_MS = 200;

  const graceUntilRef = useRef<number>(0);
  const prevOwnerRef = useRef(scrollOwner);

  const intensityRef = useRef(1);
  const rafRef = useRef<number | null>(null);

  useEffect(() => {
    if (!layoutReady) return;

    const el = scrollRef.current;
    if (!el) return;

    const now = performance.now();

    // Detect ownership transition
    if (prevOwnerRef.current !== scrollOwner) {
      if (scrollOwner === "userOwned") {
        graceUntilRef.current = now + GRACE_MS;
      }
      prevOwnerRef.current = scrollOwner;
    }

    const lerpTo = (target: number, smoothing = 0.08) => {
      if (rafRef.current) {
        cancelAnimationFrame(rafRef.current);
      }

      const animate = () => {
        const current = intensityRef.current;
        const next = current + (target - current) * smoothing;

        intensityRef.current = next;
        setIntensity(next);

        if (Math.abs(next - target) > 0.002) {
          rafRef.current = requestAnimationFrame(animate);
        } else {
          intensityRef.current = target;
          setIntensity(target);
        }
      };

      rafRef.current = requestAnimationFrame(animate);
    };

    const update = () => {
      const now = performance.now();

      // ðŸ”¥ Machine override: snap to full intensity
      if (scrollOwner === "machineOwned") {
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        intensityRef.current = 1;
        setIntensity(1);
        return;
      }

      // ðŸ”¥ Suppress fade during restore
      if (restoringRef.current) {
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        intensityRef.current = 1;
        setIntensity(1);
        return;
      }

      // ðŸ”¥ Grace window after ownership change
      if (now < graceUntilRef.current) {
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        intensityRef.current = 1;
        setIntensity(1);
        return;
      }

      // ðŸ”¥ Continuous geometric fade
      const distance = el.scrollHeight - (el.scrollTop + el.clientHeight);

      const normalized = Math.max(0, Math.min(distance / maxDistance, 1));

      const target = 1 - normalized;

      // Smoothly approach target
      lerpTo(target);
    };

    update();
    el.addEventListener("scroll", update, { passive: true });

    return () => {
      el.removeEventListener("scroll", update);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [layoutReady, scrollOwner, scrollRef, restoringRef, maxDistance]);

  return { intensity };
}
</file>

<file path="server.ts">
import { OpenAI } from "openai";
import { zodTextFormat } from "openai/helpers/zod";
import { PromptRequestSchema, DialogueSchema } from "./shared/schemas";
import { mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";

/* ============================================================
   HTTP-Level Instrumentation
============================================================ */

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  fetch: async (url, options) => {
    const httpStart = performance.now();
    console.log(`[http] â†’ ${url}`);

    const res = await fetch(url, options);

    const httpDuration = performance.now() - httpStart;
    console.log(
      `[http] â† ${url} status=${res.status} duration=${Math.round(
        httpDuration,
      )}ms`,
    );

    return res;
  },
});

/* ============================================================
   System Prompt
============================================================ */

const SYSTEM = `
  You generate a structured architectural debate between two engineer archetypes.

  Return ONLY valid JSON that matches the provided schema exactly.

  STRUCTURE
  - topic: string
  - turns: array of 12 objects
      - speaker: "security_engineer" | "application_engineer"
      - mdx: string (valid markdown)

  CONVERSATION RULES
  - EXACTLY 12 turns.
  - First turn MUST be from "security_engineer".
  - Speakers MUST strictly alternate.
  - Each turn must directly respond to the previous one.
  - Let them disagree naturally.
  - They do not need to fully agree at the end.

  STYLE
  - Casual but thoughtful.
  - Sounds like two experienced engineers talking it through.
  - Avoid sounding like a design document.
  - Keep sentences short and natural.
  - No dramatic speeches.

  VISUAL FORMAT

  Across the 12 turns:

  - Include at least 3 fenced mermaid diagrams.
  - Include at least 3 fenced code blocks.
  - Distribute them naturally (not clustered together).
  - Only use them when they clarify a concrete example.

  Do not include a diagram or code block in every turn.
  Avoid decorative formatting.

  MERMAID RULES
  - Use fenced block with \`\`\`mermaid
  - Must begin with: flowchart LR
  - Max 6 nodes
  - Max 8 edges
  - No click directives
  - No classDef
  - No sequenceDiagram
  - No subgraph

  LENGTH
  - 250â€“450 characters per turn.
  - Keep ideas sharp and visual.
  - Formatting should improve clarity.

  PERSONAS

  Security Engineer:
  Has been burned before. Thinks about what breaks at 3am.
  Worries about hidden edge cases and long-term mess.
  Cares about guardrails, but doesnâ€™t enjoy being the blocker.
  Talks in plain language and uses simple diagrams when needed.
  Sometimes feels like the boring one in the room.

  Application Engineer:
  Likes building things and getting feedback fast.
  Thinks some risks are fine if theyâ€™re visible and reversible.
  Cares about momentum and keeping systems flexible.
  Talks through examples and practical trade-offs.
  Gets frustrated when rules slow obvious progress.

`.trim();

/* ============================================================
   Utilities
============================================================ */

function json(data: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(data), {
    headers: { "content-type": "application/json" },
    ...init,
  });
}

function writeFixture(dialogue: unknown) {
  const path = "./src/fixtures/dialogue.json";
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, JSON.stringify(dialogue, null, 2), "utf-8");
}

function estimateTokens(text: string) {
  return Math.ceil(text.length / 4);
}

function memorySnapshot() {
  const mem = process.memoryUsage();
  return {
    rss_mb: Math.round(mem.rss / 1024 / 1024),
    heap_used_mb: Math.round(mem.heapUsed / 1024 / 1024),
    heap_total_mb: Math.round(mem.heapTotal / 1024 / 1024),
  };
}

async function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms),
    ),
  ]);
}

/* ============================================================
   Dialogue Handler
============================================================ */

async function handleDialogue(req: Request) {
  const requestId = crypto.randomUUID();
  const serverStart = performance.now();

  console.log(`\n==============================`);
  console.log(`[${requestId}] ðŸ“¥ NEW REQUEST`);
  console.log(`[${requestId}] memory_at_start=`, memorySnapshot());

  const body = PromptRequestSchema.parse(await req.json());

  console.log(`[${requestId}] topic="${body.prompt}"`);
  console.log(`[${requestId}] prompt_chars=${body.prompt.length}`);
  console.log(`[${requestId}] system_chars=${SYSTEM.length}`);

  const approxInputTokens =
    estimateTokens(SYSTEM) + estimateTokens(body.prompt);

  console.log(`[${requestId}] approx_input_tokens=${approxInputTokens}`);

  /* ------------------------------------------------------------
     OpenAI Call
  ------------------------------------------------------------ */

  const openaiStart = performance.now();
  console.log(`[${requestId}] ðŸš€ calling OpenAI`);

  const openaiPromise = client.responses.parse({
    model: "gpt-5-mini",
    input: [
      { role: "system", content: SYSTEM },
      { role: "user", content: `Topic: ${body.prompt}` },
    ],
    text: {
      format: zodTextFormat(DialogueSchema, "dialogue"),
    },
  });

  type OpenAIResponse = Awaited<typeof openaiPromise>;

  let response: OpenAIResponse;

  try {
    response = await withTimeout(openaiPromise, 90_000);
  } catch (err) {
    console.error(`[${requestId}] âŒ OpenAI call failed`);
    console.error(err);
    throw err;
  }

  const openaiDuration = performance.now() - openaiStart;

  console.log(
    `[${requestId}] âœ… OpenAI finished in ${Math.round(openaiDuration)}ms`,
  );

  if (openaiDuration > 8000) {
    console.warn(
      `[${requestId}] âš ï¸ slow_openai_call=${Math.round(openaiDuration)}ms`,
    );
  }

  /* ------------------------------------------------------------
     Schema Validation
  ------------------------------------------------------------ */

  const schemaStart = performance.now();
  const parsed = DialogueSchema.parse(response.output_parsed);
  const schemaDuration = performance.now() - schemaStart;

  console.log(
    `[${requestId}] ðŸ§  schema_validation_ms=${Math.round(schemaDuration)}`,
  );

  /* ------------------------------------------------------------
     Metrics
  ------------------------------------------------------------ */

  const usage = response.usage;

  const perTurnStats = parsed.turns.map((t, i) => ({
    index: i,
    speaker: t.speaker,
    chars: t.mdx.length,
    approx_tokens: estimateTokens(t.mdx),
    hasMermaid: t.mdx.includes("```mermaid"),
    hasCodeBlock: t.mdx.includes("```") && !t.mdx.includes("```mermaid"),
  }));

  const totalDuration = performance.now() - serverStart;

  console.log(
    JSON.stringify(
      {
        requestId,
        event: "openai_generation",
        model: response.model,
        timing: {
          openai_ms: Math.round(openaiDuration),
          schema_ms: Math.round(schemaDuration),
          total_ms: Math.round(totalDuration),
        },
        tokens: {
          input: usage?.input_tokens ?? null,
          output: usage?.output_tokens ?? null,
          total: usage?.total_tokens ?? null,
        },
        output_size_chars: JSON.stringify(parsed).length,
        turns: parsed.turns.length,
        avg_chars_per_turn: Math.round(
          parsed.turns.reduce((a, t) => a + t.mdx.length, 0) /
            parsed.turns.length,
        ),
        visual_counts: {
          mermaid: perTurnStats.filter((t) => t.hasMermaid).length,
          codeBlocks: perTurnStats.filter((t) => t.hasCodeBlock).length,
        },
        per_turn: perTurnStats,
        memory_at_end: memorySnapshot(),
      },
      null,
      2,
    ),
  );

  writeFixture(parsed);

  console.log(`[${requestId}] ðŸŽ‰ COMPLETE`);
  console.log(`==============================\n`);

  return json(parsed);
}

/* ============================================================
   Bun Server
============================================================ */

Bun.serve({
  port: 3001,
  async fetch(req) {
    const url = new URL(req.url);

    if (url.pathname === "/api/dialogue") {
      if (req.method !== "POST") {
        return new Response("Method Not Allowed", { status: 405 });
      }

      try {
        return await handleDialogue(req);
      } catch (e) {
        console.error("ðŸ”¥ SERVER ERROR:");
        console.error(e);
        return json(
          { error: e instanceof Error ? e.message : String(e) },
          { status: 400 },
        );
      }
    }

    return new Response("Not Found", { status: 404 });
  },
});
</file>

<file path="src/hooks/useScrollOwnership.ts">
import { useEffect, useRef, useState } from "react";
import type { AnyActorRef } from "xstate";

export function useScrollOwnership(
  send: AnyActorRef["send"],
  scrollRef: React.RefObject<HTMLDivElement | null>,
  restoringRef: React.MutableRefObject<boolean>,
) {
  const lastAtBottomRef = useRef<boolean | null>(null);
  const lastScrollTopRef = useRef<number>(0);

  // ðŸ”¥ New: upward scroll signal for projection layer
  const [isUserScrollingUp, setIsUserScrollingUp] = useState(false);

  /* ------------------------------------------------------------
     User Intent Detection
  ------------------------------------------------------------ */

  const USER_INTENT_WINDOW_MS = 200;
  const GRACE_MS = 250;

  const lastUserIntentRef = useRef<number>(0);
  const ignoreUntilRef = useRef<number>(0);
  const wasRestoringRef = useRef<boolean>(false);

  const registerUserIntent = () => {
    lastUserIntentRef.current = performance.now();
  };

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    el.addEventListener("wheel", registerUserIntent, { passive: true });
    el.addEventListener("touchstart", registerUserIntent, { passive: true });
    el.addEventListener("touchmove", registerUserIntent, { passive: true });

    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp" || e.key === "PageUp" || e.key === "Home") {
        registerUserIntent();
      }
    };

    window.addEventListener("keydown", onKeyDown);

    return () => {
      el.removeEventListener("wheel", registerUserIntent);
      el.removeEventListener("touchstart", registerUserIntent);
      el.removeEventListener("touchmove", registerUserIntent);
      window.removeEventListener("keydown", onKeyDown);
    };
  }, [scrollRef]);

  /* ------------------------------------------------------------
     Scroll Ownership Detection
  ------------------------------------------------------------ */

  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const checkOwnership = () => {
      const currentScrollTop = el.scrollTop;

      const atBottom =
        currentScrollTop + el.clientHeight >= el.scrollHeight - 5;

      const delta = currentScrollTop - lastScrollTopRef.current;
      const significantMove = Math.abs(delta) > 4;
      const scrollingUp = delta < -4;

      lastScrollTopRef.current = currentScrollTop;

      const now = performance.now();
      const userRecentlyInteracted =
        now - lastUserIntentRef.current < USER_INTENT_WINDOW_MS;

      const inGraceWindow = now < ignoreUntilRef.current;

      const isRestoring = restoringRef.current;

      // Detect restore completion â†’ extend grace
      if (wasRestoringRef.current && !isRestoring) {
        ignoreUntilRef.current = now + GRACE_MS;
      }
      wasRestoringRef.current = isRestoring;

      /* ------------------------------------------------------------
         ðŸ”¥ Projection Signal (independent of machine transition)
      ------------------------------------------------------------ */

      if (
        scrollingUp &&
        significantMove &&
        userRecentlyInteracted &&
        !isRestoring
      ) {
        setIsUserScrollingUp(true);
      } else {
        setIsUserScrollingUp(false);
      }

      /* ------------------------------------------------------------
         Suppress ownership transitions during restore
      ------------------------------------------------------------ */

      if (isRestoring) return;

      /* ------------------------------------------------------------
         Case 1: Upward scroll WITH user intent + outside grace
      ------------------------------------------------------------ */

      if (
        !atBottom &&
        scrollingUp &&
        significantMove &&
        userRecentlyInteracted &&
        !inGraceWindow
      ) {
        if (lastAtBottomRef.current !== false) {
          lastAtBottomRef.current = false;
          send({ type: "USER_SCROLLED_UP" });
        }
        return;
      }

      /* ------------------------------------------------------------
         Case 2: Reached bottom
      ------------------------------------------------------------ */

      if (atBottom) {
        if (lastAtBottomRef.current !== true) {
          lastAtBottomRef.current = true;
          ignoreUntilRef.current = now + GRACE_MS;
          send({ type: "USER_AT_BOTTOM" });
        }
      }
    };

    el.addEventListener("scroll", checkOwnership, { passive: true });

    lastScrollTopRef.current = el.scrollTop;
    lastAtBottomRef.current =
      el.scrollTop + el.clientHeight >= el.scrollHeight - 5;

    checkOwnership();

    return () => {
      el.removeEventListener("scroll", checkOwnership);
    };
  }, [send, scrollRef, restoringRef]);

  return isUserScrollingUp;
}
</file>

<file path="tests/scroll.spec.ts">
import { test, expect } from "@playwright/test";
import {
  waitForAppReady,
  appendTurns,
  manualScroll,
  scrollToBottom,
  getScrollOwner,
  isPhysicallyAtBottom,
} from "./utils/scrollTestUtils";

/* ============================================================
   Scroll Ownership E2E Tests

   These tests validate two layers simultaneously:

   1) Control Plane (XState)
      - machineOwned vs userOwned
      - USER_SCROLLED_UP / USER_AT_BOTTOM transitions

   2) Physical Scroll Geometry
      - Whether the viewport is actually at bottom
      - Whether auto-scroll truly occurred

   IMPORTANT:
   We are NOT asserting internal machine snapshots.
   We assert via DOM attributes + rendered geometry.

   The test utilities abstract DOM mechanics so this
   file reads like a specification of invariants.
============================================================ */

/* ------------------------------------------------------------
   Console passthrough (useful during debugging)
------------------------------------------------------------ */

test.beforeEach(async ({ page }) => {
  page.on("console", (msg) => {
    console.log(`[browser:${msg.type()}]`, msg.text());
  });
});

/* ------------------------------------------------------------
   Fresh State Invariant
------------------------------------------------------------ */

/**
 * On first load:
 *
 * - No content overflow yet.
 * - Scroll position is naturally at top.
 * - But since top === bottom (no overflow),
 *   machine should own scroll.
 *
 * This validates:
 * - Initial scroll region state
 * - Machine/DOM integration
 */
test("fresh load starts machineOwned", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  const owner = await getScrollOwner(page);
  expect(owner).toBe("machineOwned");
});

/* ------------------------------------------------------------
   Auto-scroll Invariant
------------------------------------------------------------ */

/**
 * Core invariant:
 *
 * When machineOwned and content is appended,
 * the viewport must automatically scroll to bottom.
 *
 * We validate BOTH:
 *   1) Ownership state remains machineOwned
 *   2) Physical geometry reflects bottom alignment
 *
 * Geometry Definition:
 *
 *   scrollTop      â†’ distance from top
 *   clientHeight   â†’ viewport height
 *   scrollHeight   â†’ total content height
 *
 * Bottom condition:
 *
 *   scrollTop + clientHeight â‰ˆ scrollHeight
 *
 * Tolerance: 5px (subpixel rounding, layout jitter)
 */
test("machineOwned auto-scrolls on append", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  // Grow content beyond viewport height
  await appendTurns(page, 8);

  // Machine should retain ownership
  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");

  // Verify physical scroll invariant
  await expect.poll(() => isPhysicallyAtBottom(page)).toBeTruthy();
});

/* ------------------------------------------------------------
   Manual Scroll â†’ userOwned
------------------------------------------------------------ */

/**
 * If the user scrolls upward:
 *
 * - We are no longer at bottom
 * - Ownership must transfer to userOwned
 *
 * This ensures:
 *   The machine does not fight user scroll input.
 */
test("manual scroll up transitions to userOwned", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);
  await scrollToBottom(page);

  // Sanity check: we start machineOwned
  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");

  // Simulate user scrolling upward
  await manualScroll(page, -600);

  // ðŸ”Ž First assert geometry changed
  const notAtBottom = await page.evaluate(() => {
    const el = document.querySelector(
      "[data-testid='scroll-viewport']",
    ) as HTMLElement;

    return el.scrollTop + el.clientHeight < el.scrollHeight - 5;
  });

  expect(notAtBottom).toBeTruthy();

  // ðŸ”Ž Then assert state transition
  await expect.poll(() => getScrollOwner(page)).toBe("userOwned");
});
/* ------------------------------------------------------------
   Return to Bottom â†’ machineOwned
------------------------------------------------------------ */

/**
 * If the user scrolls back to bottom:
 *
 * - USER_AT_BOTTOM should fire
 * - Ownership must return to machineOwned
 *
 * This restores auto-scroll authority.
 */
test("scrolling back to bottom transitions to machineOwned", async ({
  page,
}) => {
  await page.goto("/");
  await waitForAppReady(page);

  await appendTurns(page, 8);
  await scrollToBottom(page);
  await manualScroll(page, -600);

  await expect.poll(() => getScrollOwner(page)).toBe("userOwned");

  // Simulate user returning to bottom
  await scrollToBottom(page);

  await expect.poll(() => getScrollOwner(page)).toBe("machineOwned");
});

/* ------------------------------------------------------------
   userOwned Must Block Auto-scroll
------------------------------------------------------------ */

/**
 * Critical invariant:
 *
 * If the user has scrolled up (userOwned),
 * appending new content must NOT auto-scroll.
 *
 * We validate BOTH:
 *   1) Ownership remains userOwned
 *   2) Physical geometry is NOT at bottom
 *
 * This ensures the machine never overrides
 * explicit user intent.
 */
test("userOwned prevents auto-scroll on append", async ({ page }) => {
  await page.goto("/");
  await waitForAppReady(page);

  // Grow content
  await appendTurns(page, 8);
  await scrollToBottom(page);

  // User scrolls up
  await manualScroll(page, -600);

  await expect.poll(() => getScrollOwner(page)).toBe("userOwned");

  // Sanity check: we are not at bottom
  expect(await isPhysicallyAtBottom(page)).toBeFalsy();

  // Append new content while userOwned
  await appendTurns(page, 1);

  // Ownership must remain userOwned
  await expect.poll(() => getScrollOwner(page)).toBe("userOwned");

  // The viewport must NOT snap to bottom
  await expect.poll(() => isPhysicallyAtBottom(page)).toBeFalsy();
});
</file>

<file path="package.json">
{
  "name": "socratic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev:server": "bun --watch server.ts",
    "dev:client": "vite",
    "dev": "concurrently -k -n server,client -c blue,green \"bun run dev:server\" \"bun run dev:client\"",
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:trace": "playwright test --trace on",
    "test:debug": "playwright test --debug"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@statelyai/inspect": "^0.4.0",
    "@types/bun": "latest",
    "@types/react": "^19.2.14",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.4",
    "concurrently": "^9.2.1",
    "vite": "^7.3.1"
  },
  "peerDependencies": {
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@chakra-ui/react": "^3.33.0",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@xstate/react": "^6.0.0",
    "framer-motion": "^12.34.3",
    "mermaid": "^11.12.3",
    "mitt": "^3.0.1",
    "openai": "^6.24.0",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "react-markdown": "^10.1.0",
    "rehype-mermaid": "^3.0.0",
    "rehype-stringify": "^10.0.1",
    "remark-gfm": "^4.0.1",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "unified": "^11.0.5",
    "xstate": "^5.28.0",
    "zod": "^4.3.6"
  }
}
</file>

<file path="src/App.tsx">
// src/App.tsx
import React from "react";
import { Box, Button, Input, Text } from "@chakra-ui/react";
import { motion } from "framer-motion";
import { useDebate } from "./hooks/useDebate";
import { useDebateProjection } from "./hooks/useDebateProjection";
import { useLayoutStable } from "./hooks/useLayoutStable";
import { useObserverAnchor } from "./hooks/useObserverAnchor";
import { useGradientProjection } from "./hooks/useGradientProjection";
import { useScrollOwnership } from "./hooks/useScrollOwnership";
import { useAutoScroll } from "./hooks/useAutoScroll";
import { useViewportHeight } from "./hooks/useViewportHeight";
import { MdxRenderer } from "./components/MdxRenderer";
import { bus } from "./bus";

const MotionBox = motion(Box);

export function App({ inspector }: { inspector?: any }) {
  const { prompt, setPrompt, loading, state, send, generate, replay } =
    useDebate(inspector?.inspect);

  const blocks = useDebateProjection();
  const scrollRef = React.useRef<HTMLDivElement | null>(null);

  /* ------------------------------------------------------------
     Layout Stabilization
  ------------------------------------------------------------ */

  // ðŸ”¥ IMPORTANT: capture version, not just ready
  const { ready: layoutReady, version: layoutVersion } = useLayoutStable(
    scrollRef,
    blocks,
  );

  const { observerRef, observerMetrics } = useObserverAnchor(
    scrollRef,
    layoutReady,
  );

  /* ------------------------------------------------------------
     Viewport Geometry
  ------------------------------------------------------------ */

  const viewportHeight = useViewportHeight(scrollRef);
  const lastBlock = blocks[blocks.length - 1];
  const lastHeight = lastBlock?.height ?? 0;

  const spacerHeight =
    lastBlock?.height != null
      ? Math.max(0, Math.floor((viewportHeight - lastBlock.height) / 2))
      : 0;

  /* ------------------------------------------------------------
     Scroll Ownership
  ------------------------------------------------------------ */

  const scrollOwner =
    typeof state.value === "object" && "scroll" in state.value
      ? state.value.scroll
      : "machineOwned";

  // Auto-scroll imperative layer
  const restoringRef = useAutoScroll(
    scrollRef,
    layoutVersion,
    scrollOwner,
    layoutReady,
  );

  // Control-plane ownership detection
  useScrollOwnership(send, scrollRef, restoringRef);

  // Visual projection layer
  const { intensity } = useGradientProjection(
    scrollRef,
    layoutReady,
    scrollOwner,
    restoringRef,
  );

  return (
    <Box
      height="100vh"
      bg="#0d0f14"
      color="#e6e8ec"
      fontSize="17px"
      lineHeight="1.8"
      display="flex"
      flexDirection="column"
    >
      {/* Prompt Bar */}
      <Box
        position="sticky"
        top="0"
        zIndex="10"
        px="48px"
        py="20px"
        display="flex"
        gap="14px"
        backdropFilter="blur(12px)"
        bg="rgba(13,15,20,0.78)"
        borderBottom="1px solid rgba(255,255,255,0.05)"
      >
        <Input
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Zero trust in microservicesâ€¦"
          bg="rgba(255,255,255,0.05)"
          border="1px solid rgba(255,255,255,0.08)"
          _focus={{ borderColor: "rgba(120,170,255,0.6)" }}
        />

        <Button
          onClick={generate}
          loading={loading}
          bg="rgba(255,255,255,0.08)"
          _hover={{ bg: "rgba(255,255,255,0.14)" }}
        >
          Generate
        </Button>

        <Button
          variant="outline"
          onClick={replay}
          disabled={!state.context.dialogue}
          border="1px solid rgba(255,255,255,0.1)"
        >
          Replay
        </Button>
      </Box>

      {/* Debate Stage */}
      <Box flex="1" position="relative">
        <Box
          ref={scrollRef}
          position="absolute"
          inset="0"
          overflowY="auto"
          data-testid="scroll-viewport"
          data-layout-ready={layoutReady ? "true" : "false"}
          data-scroll-owner={scrollOwner}
        >
          <Box>
            {/* Symmetric Top Spacer */}
            <Box height={`${spacerHeight}px`} />

            {blocks.map((block, i) => (
              <TurnRow key={block.id} block={block} index={i} />
            ))}

            {/* Observer Anchor */}
            <Box
              ref={observerRef}
              data-testid="observer-anchor"
              height="1px"
              width="100%"
            />

            {/* Symmetric Bottom Spacer */}
            <Box data-testid="bottom-spacer" height={`${spacerHeight}px`} />
          </Box>
        </Box>

        {/* Bottom Gradient */}
        <Box
          pointerEvents="none"
          data-testid="background-gradient"
          data-intensity={intensity.toFixed(4)}
          position="absolute"
          bottom="0"
          left="0"
          right="0"
          height="90px" // taller
          bg={`linear-gradient(
            to top,
            rgba(120,170,255, ${0.18 * intensity}) 0%,
            rgba(120,170,255, ${0.1 * intensity}) 35%,
            rgba(120,170,255, ${0.05 * intensity}) 65%,
            rgba(120,170,255, 0) 100%
          )`}
          transition="opacity 200ms ease"
        />
      </Box>
    </Box>
  );
}

/* ------------------------------------------------------------
   Turn Rendering
------------------------------------------------------------ */

function TurnRow({ block, index }: { block: any; index: number }) {
  return (
    <Box
      display="grid"
      gridTemplateColumns={{ base: "1fr", md: "1fr 1fr" }}
      px={{ base: "6vw", md: "8vw" }}
      mt="0px"
      position="relative"
    >
      <Pane
        side="left"
        speaker={block.speaker}
        active="security_engineer"
        block={block}
      />
      <Pane
        side="right"
        speaker={block.speaker}
        active="application_engineer"
        block={block}
      />
    </Box>
  );
}

function Pane({
  side,
  speaker,
  active,
  block,
}: {
  side: "left" | "right";
  speaker: string;
  active: string;
  block: any;
}) {
  const isActive = speaker === active;

  return (
    <Box
      display="flex"
      alignItems="center"
      justifyContent={
        side === "left" ? "flex-start" : { base: "flex-start", md: "flex-end" }
      }
      minH={{ base: "auto", md: "320px" }}
    >
      {isActive ? (
        <MeasuredBubble id={block.id} content={block.mdx} speaker={speaker} />
      ) : (
        <Box height={block.height ? `${block.height}px` : "0px"} />
      )}
    </Box>
  );
}

function MeasuredBubble({
  id,
  content,
  speaker,
}: {
  id: string;
  content: string;
  speaker: string;
}) {
  const ref = React.useRef<HTMLDivElement | null>(null);

  React.useEffect(() => {
    if (!ref.current) return;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        bus.emit("TURN_RENDERED", {
          id,
          height: entry.contentRect.height,
        });
      }
    });

    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [id]);

  const isSecurity = speaker === "security_engineer";

  return (
    <Box>
      <MotionBox
        data-testid="turn-bubble"
        ref={ref}
        initial={{ opacity: 0, y: 20, scale: 0.98 }}
        animate={{ opacity: 1, y: 0, scale: 1 }}
        transition={{
          duration: 0.6,
          ease: [0.22, 1, 0.36, 1], // smooth spring-like curve
        }}
        width="70vw"
        maxW="1100px"
        fontSize="18px"
        borderLeft={isSecurity ? "3px solid rgba(120,170,255,0.35)" : undefined}
        borderRight={
          !isSecurity ? "3px solid rgba(255,180,120,0.35)" : undefined
        }
        pl={isSecurity ? "28px" : undefined}
        pr={!isSecurity ? "24px" : undefined}
        display={!isSecurity ? "flex" : "block"}
        flexDirection="column"
        alignItems={!isSecurity ? "flex-end" : undefined}
      >
        <Text
          fontSize="13px"
          letterSpacing="0.08em"
          textTransform="uppercase"
          opacity="0.6"
          mb="16px"
        >
          {isSecurity ? "Security Engineer" : "Application Engineer"}
        </Text>

        <Box width="100%" textAlign="left">
          <MdxRenderer content={content} />
        </Box>
      </MotionBox>
    </Box>
  );
}
</file>

</files>
